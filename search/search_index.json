{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 1. Theoretical Foundation Governing Equations of Motion To analyze projectile motion, we start with Newton\u2019s laws and decompose the motion into two perpendicular components: horizontal (x-axis) and vertical (y-axis). Assuming no air resistance and a flat surface, the equations of motion are: Horizontal motion: \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] Vertical motion: \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] Where: - \\( v_0 \\) is the initial speed, - \\( \\theta \\) is the launch angle, - \\( g \\) is the acceleration due to gravity, - \\( t \\) is time. Time of Flight The projectile returns to the ground when its vertical position becomes zero: \\[ y(t) = 0 \\] Solving for \\( t \\) : \\[ t = \\frac{2v_0 \\cdot \\sin(\\theta)}{g} \\] This represents the total time of flight . Range of the Projectile Substitute the time of flight into the horizontal equation: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2v_0 \\cdot \\sin(\\theta)}{g} \\] Using the trigonometric identity \\( 2 \\cdot \\sin(\\theta) \\cdot \\cos(\\theta) = \\sin(2\\theta) \\) , we simplify: \\[ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Family of Solutions This final equation shows that the range \\( R \\) depends on: - the square of the initial speed \\( v_0 \\) , - the sine of twice the launch angle \\( \\theta \\) , - and the gravitational acceleration \\( g \\) . For fixed \\( v_0 \\) and \\( g \\) , the range varies only with the launch angle , forming a family of solutions that can be explored analytically and computationally. 2. Analysis of the Range Behavior of the Range Function From the equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] we observe that the range \\( R \\) depends on the sine of twice the launch angle \\( \\theta \\) . This means: - The function \\( \\sin(2\\theta) \\) reaches its maximum value of 1 when \\( 2\\theta = 90^\\circ \\) , i.e. \\( \\theta = 45^\\circ \\) . - Therefore, the maximum range is achieved when the projectile is launched at an angle of 45\u00b0 . Symmetry in the Range The function \\( \\sin(2\\theta) \\) is symmetric around \\( \\theta = 45^\\circ \\) . This implies that: \\[ R(\\theta) = R(90^\\circ - \\theta) \\] Example: - A launch at \\( 30^\\circ \\) gives the same range as a launch at \\( 60^\\circ \\) . - Likewise, \\( 20^\\circ \\) and \\( 70^\\circ \\) give the same range. This symmetry creates pairs of angles with identical range values, despite different trajectories. Implications The same horizontal distance can be achieved with different angles, but: - Lower angles produce flatter, faster trajectories. - Higher angles result in higher arcs with longer air time. Visual Expectation A plot of \\( R(\\theta) \\) versus \\( \\theta \\) from \\( 0^\\circ \\) to \\( 90^\\circ \\) will form a symmetric curve , peaking at \\( 45^\\circ \\) . This provides a solid foundation for experimental simulation or numerical analysis to visualize this behavior. 3. Code Implementation To analyze the relationship between the launch angle and the projectile range, we simulate the motion using Python with numpy and matplotlib . Python Code import numpy as np import matplotlib.pyplot as plt # Constants v0 = 10 # initial velocity in m/s g = 9.8 # acceleration due to gravity in m/s^2 # Angle range from 0 to 90 degrees angles_deg = np.linspace(0, 90, 1000) angles_rad = np.deg2rad(angles_deg) # Range formula range_values = (v0**2 * np.sin(2 * angles_rad)) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles_deg, range_values, label='Range vs Angle', color='teal') plt.axvline(45, color='gray', linestyle='--', label='Maximum Range at 45\u00b0') plt.title('Projectile Range as a Function of Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.tight_layout() plt.show() 4. Graph and Interpretation Visualization Overview The plot generated by the simulation shows how the projectile range varies with respect to the launch angle \\( \\theta \\) from 0\u00b0 to 90\u00b0. Key observations: - The range increases as the angle increases from 0\u00b0 to 45\u00b0. - The maximum range is achieved at 45\u00b0 . - Beyond 45\u00b0, the range decreases symmetrically , approaching zero at 90\u00b0. - The plot is symmetric around 45\u00b0, confirming that: \\[ R(\\theta) = R(90^\\circ - \\theta) \\] This illustrates that different launch angles can result in the same horizontal distance but with different flight characteristics (trajectory height and flight time). Real-World Insight Such graphical analysis provides a deeper understanding of projectile motion: - In sports, optimizing throw or kick angles improves performance. - In engineering, ideal launch angles reduce energy costs or material usage. - In aerospace, it helps model ideal launch trajectories (neglecting drag). This visualization confirms the theoretical predictions and provides a strong foundation for exploring more complex or real-world scenarios in future sections. 5. Limitations and Further Improvements Idealized Assumptions This model makes several simplifying assumptions: - No air resistance : In reality, drag significantly affects the range, especially at higher velocities. - Launch from ground level : The model does not account for launches from elevated platforms or terrains. - Constant gravity : Gravitational acceleration is treated as constant, though it can vary slightly with altitude or location. - No wind or atmospheric effects : Wind direction and speed can greatly alter projectile behavior. Possible Extensions To increase realism, future versions of the model can include: - Air resistance (quadratic drag or using differential equations), - Launch from an arbitrary height, - Custom terrain elevation or slope, - Variable gravitational environments (e.g., other planets), - 3D projectile motion. These refinements make the model more applicable to engineering, aerospace, and defense systems where precision is critical.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-of-motion","text":"To analyze projectile motion, we start with Newton\u2019s laws and decompose the motion into two perpendicular components: horizontal (x-axis) and vertical (y-axis). Assuming no air resistance and a flat surface, the equations of motion are: Horizontal motion: \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] Vertical motion: \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2 \\] Where: - \\( v_0 \\) is the initial speed, - \\( \\theta \\) is the launch angle, - \\( g \\) is the acceleration due to gravity, - \\( t \\) is time.","title":"Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The projectile returns to the ground when its vertical position becomes zero: \\[ y(t) = 0 \\] Solving for \\( t \\) : \\[ t = \\frac{2v_0 \\cdot \\sin(\\theta)}{g} \\] This represents the total time of flight .","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-of-the-projectile","text":"Substitute the time of flight into the horizontal equation: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2v_0 \\cdot \\sin(\\theta)}{g} \\] Using the trigonometric identity \\( 2 \\cdot \\sin(\\theta) \\cdot \\cos(\\theta) = \\sin(2\\theta) \\) , we simplify: \\[ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\]","title":"Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"This final equation shows that the range \\( R \\) depends on: - the square of the initial speed \\( v_0 \\) , - the sine of twice the launch angle \\( \\theta \\) , - and the gravitational acceleration \\( g \\) . For fixed \\( v_0 \\) and \\( g \\) , the range varies only with the launch angle , forming a family of solutions that can be explored analytically and computationally.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#behavior-of-the-range-function","text":"From the equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] we observe that the range \\( R \\) depends on the sine of twice the launch angle \\( \\theta \\) . This means: - The function \\( \\sin(2\\theta) \\) reaches its maximum value of 1 when \\( 2\\theta = 90^\\circ \\) , i.e. \\( \\theta = 45^\\circ \\) . - Therefore, the maximum range is achieved when the projectile is launched at an angle of 45\u00b0 .","title":"Behavior of the Range Function"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#symmetry-in-the-range","text":"The function \\( \\sin(2\\theta) \\) is symmetric around \\( \\theta = 45^\\circ \\) . This implies that: \\[ R(\\theta) = R(90^\\circ - \\theta) \\] Example: - A launch at \\( 30^\\circ \\) gives the same range as a launch at \\( 60^\\circ \\) . - Likewise, \\( 20^\\circ \\) and \\( 70^\\circ \\) give the same range. This symmetry creates pairs of angles with identical range values, despite different trajectories.","title":"Symmetry in the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implications","text":"The same horizontal distance can be achieved with different angles, but: - Lower angles produce flatter, faster trajectories. - Higher angles result in higher arcs with longer air time.","title":"Implications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#visual-expectation","text":"A plot of \\( R(\\theta) \\) versus \\( \\theta \\) from \\( 0^\\circ \\) to \\( 90^\\circ \\) will form a symmetric curve , peaking at \\( 45^\\circ \\) . This provides a solid foundation for experimental simulation or numerical analysis to visualize this behavior.","title":"Visual Expectation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-code-implementation","text":"To analyze the relationship between the launch angle and the projectile range, we simulate the motion using Python with numpy and matplotlib .","title":"3. Code Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants v0 = 10 # initial velocity in m/s g = 9.8 # acceleration due to gravity in m/s^2 # Angle range from 0 to 90 degrees angles_deg = np.linspace(0, 90, 1000) angles_rad = np.deg2rad(angles_deg) # Range formula range_values = (v0**2 * np.sin(2 * angles_rad)) / g # Plotting plt.figure(figsize=(10, 6)) plt.plot(angles_deg, range_values, label='Range vs Angle', color='teal') plt.axvline(45, color='gray', linestyle='--', label='Maximum Range at 45\u00b0') plt.title('Projectile Range as a Function of Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-graph-and-interpretation","text":"","title":"4. Graph and Interpretation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#visualization-overview","text":"The plot generated by the simulation shows how the projectile range varies with respect to the launch angle \\( \\theta \\) from 0\u00b0 to 90\u00b0. Key observations: - The range increases as the angle increases from 0\u00b0 to 45\u00b0. - The maximum range is achieved at 45\u00b0 . - Beyond 45\u00b0, the range decreases symmetrically , approaching zero at 90\u00b0. - The plot is symmetric around 45\u00b0, confirming that: \\[ R(\\theta) = R(90^\\circ - \\theta) \\] This illustrates that different launch angles can result in the same horizontal distance but with different flight characteristics (trajectory height and flight time).","title":"Visualization Overview"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-insight","text":"Such graphical analysis provides a deeper understanding of projectile motion: - In sports, optimizing throw or kick angles improves performance. - In engineering, ideal launch angles reduce energy costs or material usage. - In aerospace, it helps model ideal launch trajectories (neglecting drag). This visualization confirms the theoretical predictions and provides a strong foundation for exploring more complex or real-world scenarios in future sections.","title":"Real-World Insight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-further-improvements","text":"","title":"5. Limitations and Further Improvements"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#idealized-assumptions","text":"This model makes several simplifying assumptions: - No air resistance : In reality, drag significantly affects the range, especially at higher velocities. - Launch from ground level : The model does not account for launches from elevated platforms or terrains. - Constant gravity : Gravitational acceleration is treated as constant, though it can vary slightly with altitude or location. - No wind or atmospheric effects : Wind direction and speed can greatly alter projectile behavior.","title":"Idealized Assumptions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#possible-extensions","text":"To increase realism, future versions of the model can include: - Air resistance (quadratic drag or using differential equations), - Launch from an arbitrary height, - Custom terrain elevation or slope, - Variable gravitational environments (e.g., other planets), - 3D projectile motion. These refinements make the model more applicable to engineering, aerospace, and defense systems where precision is critical.","title":"Possible Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 1. Theoretical Foundation Governing Equation of Motion The motion of a forced damped pendulum is described by the second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta \\) \u2014 the angular displacement - \\( b \\) \u2014 the damping coefficient - \\( g \\) \u2014 the gravitational acceleration - \\( L \\) \u2014 the length of the pendulum - \\( A \\) \u2014 the amplitude of the external driving force - \\( \\omega \\) \u2014 the driving angular frequency - \\( t \\) \u2014 time Small-Angle Approximation For small angular displacements ( \\( \\theta \\) close to zero), we can approximate: \\[ \\sin(\\theta) \\approx \\theta \\] Substituting this into the governing equation gives: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This simplifies the system to a linear second-order nonhomogeneous differential equation with constant coefficients. Interpretation of Terms The term \\( b\\frac{d\\theta}{dt} \\) represents energy dissipation due to damping. The term \\( \\frac{g}{L}\\theta \\) represents the restoring force due to gravity. The right-hand side \\( A\\cos(\\omega t) \\) represents an external periodic driving force . Depending on the values of \\( b \\) , \\( A \\) , and \\( \\omega \\) , the system can exhibit: Steady-state periodic motion Resonance phenomena Quasiperiodic or chaotic behavior Resonance Condition In the absence of damping and under the small-angle approximation, resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) of the pendulum: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] Under resonance: The amplitude of oscillations becomes significantly large. Energy transfer from the external driving force to the pendulum is maximized. However, real systems with damping exhibit limited amplitudes and more complex resonance behavior. 2. Analysis of Dynamics The behavior of the forced damped pendulum is strongly influenced by three key parameters: Damping coefficient ( \\( b \\) ) Higher damping leads to quicker energy dissipation, causing oscillations to decay faster. Lower damping allows oscillations to persist and can enable complex dynamics, including chaotic motion. Driving amplitude ( \\( A \\) ) A small driving amplitude results in regular, predictable oscillations. A larger driving amplitude can push the system into nonlinear and chaotic behavior. Driving frequency ( \\( \\omega \\) ) When the driving frequency approaches the system\u2019s natural frequency ( \\( \\omega_0 \\) ), resonance occurs, greatly amplifying oscillation amplitudes. Away from resonance, the response is much smaller. Transition from Regular to Chaotic Motion As the driving amplitude \\( A \\) or the driving frequency \\( \\omega \\) increases, the system exhibits the following transitions: Periodic motion Regular, repeating oscillations over time. Quasiperiodic motion Oscillations combining two or more frequencies, leading to a non-repeating but structured pattern. Chaotic motion Highly sensitive to initial conditions, with irregular, unpredictable behavior. Characterized by positive Lyapunov exponents and complex structures in phase space. 3. Practical Applications The forced damped pendulum model, while idealized, has important applications in various real-world systems where periodic driving and damping effects are present. Energy Harvesting Devices Systems such as piezoelectric energy harvesters rely on oscillations induced by ambient vibrations. Understanding resonance and damping helps optimize energy extraction. Suspension Bridges Suspension bridges are susceptible to wind-induced oscillations, which can lead to resonance phenomena. Proper damping mechanisms are critical to prevent catastrophic failures, such as the Tacoma Narrows Bridge collapse. Oscillating Electrical Circuits Driven RLC circuits (resistor-inductor-capacitor systems) behave analogously to forced damped pendulums. Analysis of resonance and damping is essential for the design of stable and efficient electronic systems. Biomechanics and Gait Analysis Human gait dynamics under external perturbations (e.g., uneven surfaces or wearable devices) can be modeled similarly. Damping and external forcing play roles in maintaining balance and stability. These practical examples demonstrate the relevance of the forced damped pendulum model beyond theoretical physics, providing insight into engineering, biomechanics, and energy systems. 4. Implementation To explore the behavior of the forced damped pendulum, we develop a computational model using Python. We use a numerical method, specifically the fourth-order Runge-Kutta method ( scipy.integrate.solve_ivp ), to solve the system of ordinary differential equations (ODEs). Mathematical Model The second-order differential equation describing the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] This can be rewritten as a system of two first-order equations: \\[ \\frac{d\\theta}{dt} = \\omega \\quad \\quad \\frac{d\\omega}{dt} = -b\\omega - \\frac{g}{L} \\sin(\\theta) + A \\cos(\\omega_{\\text{drive}} t) \\] where: - \\( \\theta \\) is the angular displacement, - \\( \\omega \\) is the angular velocity, - \\( b \\) is the damping coefficient, - \\( g \\) is the gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external driving force, - \\( \\omega_{\\text{drive}} \\) is the driving angular frequency. Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.8 # gravitational acceleration (m/s^2) L = 1.0 # length of pendulum (m) b = 0.2 # damping coefficient A = 1.2 # amplitude of driving force omega_drive = 2/3 # driving frequency (rad/s) # Time span t_span = (0, 60) t_eval = np.linspace(t_span[0], t_span[1], 1000) # System of equations def pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g/L) * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] # Initial conditions y0 = [0.2, 0.0] # Small initial angle, zero initial velocity # Solve ODE solution = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Extract results theta = solution.y[0] omega = solution.y[1] time = solution.t # Normalize theta to [-pi, pi] theta = (theta + np.pi) % (2 * np.pi) - np.pi # Plotting plt.figure(figsize=(12, 6)) # Angle vs Time plt.subplot(2, 1, 1) plt.plot(time, theta, label='Theta (angle)') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.title('Angle vs Time') plt.grid(True) plt.legend() # Phase Portrait plt.subplot(2, 1, 2) plt.plot(theta, omega, '.', markersize=1, label='Phase Portrait') plt.xlabel('Angle (radians)') plt.ylabel('Angular velocity (rad/s)') plt.title('Phase Portrait') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visualization Overview Angle vs Time Shows how the pendulum's angle evolves under the combined effects of damping and external forcing. Phase Portrait Plots angular velocity versus angle to visualize the dynamical behavior of the system. In chaotic regimes, the phase portrait appears scattered and complex. 6. Advanced Visualizations This section presents additional tools for analyzing the complex behavior of the forced damped pendulum. These include: Poincar\u00e9 sections : useful for visualizing transitions to chaos by sampling the phase space at regular intervals. Bifurcation diagrams : show how the system\u2019s behavior evolves as a parameter (typically the driving amplitude \\( A \\) ) changes. Poincar\u00e9 Section The Poincar\u00e9 section is constructed by sampling the state \\((\\theta, \\omega)\\) once per driving cycle: \\[ T = \\frac{2\\pi}{\\omega_{\\text{drive}}} \\] Only values at \\( t_n = nT \\) are recorded, providing a simplified view of the system's long-term behavior. # Define driving period T_drive = 2 * np.pi / omega_drive sample_times = np.arange(0, t_span[1], T_drive) # Solve the ODE with dense output solution_dense = solve_ivp(pendulum, t_span, y0, dense_output=True) # Sample at multiples of T poincare = solution_dense.sol(sample_times) theta_p = (poincare[0] + np.pi) % (2 * np.pi) - np.pi omega_p = poincare[1] # Plot Poincar\u00e9 section plt.figure(figsize=(6, 6)) plt.plot(theta_p, omega_p, 'o', markersize=2) plt.xlabel('Angle (radians)') plt.ylabel('Angular velocity (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid(True) plt.show() Periodic motion produces discrete points. Quasiperiodic motion forms closed curves. Chaotic motion leads to scattered, dense regions. Bifurcation Diagram In this plot, the driving amplitude \\( A \\) is gradually varied. For each value, the system's angle is sampled once per cycle (after transients) to observe how behavior changes: A_values = np.linspace(1.0, 1.6, 200) theta_samples = [] for A_current in A_values: def pendulum_A(t, y): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g/L) * np.sin(theta) + A_current * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] sol = solve_ivp(pendulum_A, (0, 300), y0, dense_output=True) # Sample last 50 cycles after transient T = 2 * np.pi / omega_drive times = np.arange(250, 300, T) sampled = sol.sol(times) thetas = (sampled[0] + np.pi) % (2 * np.pi) - np.pi theta_samples.append(thetas) # Plot bifurcation diagram plt.figure(figsize=(10, 6)) for i, A_val in enumerate(A_values): plt.plot([A_val]*len(theta_samples[i]), theta_samples[i], ',k') plt.xlabel('Driving Amplitude (A)') plt.ylabel('Angle (radians)') plt.title('Bifurcation Diagram') plt.grid(True) plt.show() The diagram shows stable periodic orbits, period doubling bifurcations, and transitions to chaos as \\( A \\) increases. Summary These advanced visualizations help identify and classify dynamic regimes: Phase portraits : visualize continuous trajectories. Poincar\u00e9 sections : reduce dimensionality, reveal structure. Bifurcation diagrams : track system response to parameter changes. Together, they provide powerful insight into nonlinear dynamics and chaotic systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation-of-motion","text":"The motion of a forced damped pendulum is described by the second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta \\) \u2014 the angular displacement - \\( b \\) \u2014 the damping coefficient - \\( g \\) \u2014 the gravitational acceleration - \\( L \\) \u2014 the length of the pendulum - \\( A \\) \u2014 the amplitude of the external driving force - \\( \\omega \\) \u2014 the driving angular frequency - \\( t \\) \u2014 time","title":"Governing Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angular displacements ( \\( \\theta \\) close to zero), we can approximate: \\[ \\sin(\\theta) \\approx \\theta \\] Substituting this into the governing equation gives: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This simplifies the system to a linear second-order nonhomogeneous differential equation with constant coefficients.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#interpretation-of-terms","text":"The term \\( b\\frac{d\\theta}{dt} \\) represents energy dissipation due to damping. The term \\( \\frac{g}{L}\\theta \\) represents the restoring force due to gravity. The right-hand side \\( A\\cos(\\omega t) \\) represents an external periodic driving force . Depending on the values of \\( b \\) , \\( A \\) , and \\( \\omega \\) , the system can exhibit: Steady-state periodic motion Resonance phenomena Quasiperiodic or chaotic behavior","title":"Interpretation of Terms"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"In the absence of damping and under the small-angle approximation, resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) of the pendulum: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] Under resonance: The amplitude of oscillations becomes significantly large. Energy transfer from the external driving force to the pendulum is maximized. However, real systems with damping exhibit limited amplitudes and more complex resonance behavior.","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The behavior of the forced damped pendulum is strongly influenced by three key parameters: Damping coefficient ( \\( b \\) ) Higher damping leads to quicker energy dissipation, causing oscillations to decay faster. Lower damping allows oscillations to persist and can enable complex dynamics, including chaotic motion. Driving amplitude ( \\( A \\) ) A small driving amplitude results in regular, predictable oscillations. A larger driving amplitude can push the system into nonlinear and chaotic behavior. Driving frequency ( \\( \\omega \\) ) When the driving frequency approaches the system\u2019s natural frequency ( \\( \\omega_0 \\) ), resonance occurs, greatly amplifying oscillation amplitudes. Away from resonance, the response is much smaller.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-from-regular-to-chaotic-motion","text":"As the driving amplitude \\( A \\) or the driving frequency \\( \\omega \\) increases, the system exhibits the following transitions: Periodic motion Regular, repeating oscillations over time. Quasiperiodic motion Oscillations combining two or more frequencies, leading to a non-repeating but structured pattern. Chaotic motion Highly sensitive to initial conditions, with irregular, unpredictable behavior. Characterized by positive Lyapunov exponents and complex structures in phase space.","title":"Transition from Regular to Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model, while idealized, has important applications in various real-world systems where periodic driving and damping effects are present.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-harvesting-devices","text":"Systems such as piezoelectric energy harvesters rely on oscillations induced by ambient vibrations. Understanding resonance and damping helps optimize energy extraction.","title":"Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#suspension-bridges","text":"Suspension bridges are susceptible to wind-induced oscillations, which can lead to resonance phenomena. Proper damping mechanisms are critical to prevent catastrophic failures, such as the Tacoma Narrows Bridge collapse.","title":"Suspension Bridges"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#oscillating-electrical-circuits","text":"Driven RLC circuits (resistor-inductor-capacitor systems) behave analogously to forced damped pendulums. Analysis of resonance and damping is essential for the design of stable and efficient electronic systems.","title":"Oscillating Electrical Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#biomechanics-and-gait-analysis","text":"Human gait dynamics under external perturbations (e.g., uneven surfaces or wearable devices) can be modeled similarly. Damping and external forcing play roles in maintaining balance and stability. These practical examples demonstrate the relevance of the forced damped pendulum model beyond theoretical physics, providing insight into engineering, biomechanics, and energy systems.","title":"Biomechanics and Gait Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"To explore the behavior of the forced damped pendulum, we develop a computational model using Python. We use a numerical method, specifically the fourth-order Runge-Kutta method ( scipy.integrate.solve_ivp ), to solve the system of ordinary differential equations (ODEs).","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#mathematical-model","text":"The second-order differential equation describing the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] This can be rewritten as a system of two first-order equations: \\[ \\frac{d\\theta}{dt} = \\omega \\quad \\quad \\frac{d\\omega}{dt} = -b\\omega - \\frac{g}{L} \\sin(\\theta) + A \\cos(\\omega_{\\text{drive}} t) \\] where: - \\( \\theta \\) is the angular displacement, - \\( \\omega \\) is the angular velocity, - \\( b \\) is the damping coefficient, - \\( g \\) is the gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external driving force, - \\( \\omega_{\\text{drive}} \\) is the driving angular frequency.","title":"Mathematical Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g = 9.8 # gravitational acceleration (m/s^2) L = 1.0 # length of pendulum (m) b = 0.2 # damping coefficient A = 1.2 # amplitude of driving force omega_drive = 2/3 # driving frequency (rad/s) # Time span t_span = (0, 60) t_eval = np.linspace(t_span[0], t_span[1], 1000) # System of equations def pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g/L) * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] # Initial conditions y0 = [0.2, 0.0] # Small initial angle, zero initial velocity # Solve ODE solution = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Extract results theta = solution.y[0] omega = solution.y[1] time = solution.t # Normalize theta to [-pi, pi] theta = (theta + np.pi) % (2 * np.pi) - np.pi # Plotting plt.figure(figsize=(12, 6)) # Angle vs Time plt.subplot(2, 1, 1) plt.plot(time, theta, label='Theta (angle)') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.title('Angle vs Time') plt.grid(True) plt.legend() # Phase Portrait plt.subplot(2, 1, 2) plt.plot(theta, omega, '.', markersize=1, label='Phase Portrait') plt.xlabel('Angle (radians)') plt.ylabel('Angular velocity (rad/s)') plt.title('Phase Portrait') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualization-overview","text":"Angle vs Time Shows how the pendulum's angle evolves under the combined effects of damping and external forcing. Phase Portrait Plots angular velocity versus angle to visualize the dynamical behavior of the system. In chaotic regimes, the phase portrait appears scattered and complex.","title":"Visualization Overview"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-advanced-visualizations","text":"This section presents additional tools for analyzing the complex behavior of the forced damped pendulum. These include: Poincar\u00e9 sections : useful for visualizing transitions to chaos by sampling the phase space at regular intervals. Bifurcation diagrams : show how the system\u2019s behavior evolves as a parameter (typically the driving amplitude \\( A \\) ) changes.","title":"6. Advanced Visualizations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section","text":"The Poincar\u00e9 section is constructed by sampling the state \\((\\theta, \\omega)\\) once per driving cycle: \\[ T = \\frac{2\\pi}{\\omega_{\\text{drive}}} \\] Only values at \\( t_n = nT \\) are recorded, providing a simplified view of the system's long-term behavior. # Define driving period T_drive = 2 * np.pi / omega_drive sample_times = np.arange(0, t_span[1], T_drive) # Solve the ODE with dense output solution_dense = solve_ivp(pendulum, t_span, y0, dense_output=True) # Sample at multiples of T poincare = solution_dense.sol(sample_times) theta_p = (poincare[0] + np.pi) % (2 * np.pi) - np.pi omega_p = poincare[1] # Plot Poincar\u00e9 section plt.figure(figsize=(6, 6)) plt.plot(theta_p, omega_p, 'o', markersize=2) plt.xlabel('Angle (radians)') plt.ylabel('Angular velocity (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid(True) plt.show() Periodic motion produces discrete points. Quasiperiodic motion forms closed curves. Chaotic motion leads to scattered, dense regions.","title":"Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#bifurcation-diagram","text":"In this plot, the driving amplitude \\( A \\) is gradually varied. For each value, the system's angle is sampled once per cycle (after transients) to observe how behavior changes: A_values = np.linspace(1.0, 1.6, 200) theta_samples = [] for A_current in A_values: def pendulum_A(t, y): theta, omega = y dtheta_dt = omega domega_dt = -b * omega - (g/L) * np.sin(theta) + A_current * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] sol = solve_ivp(pendulum_A, (0, 300), y0, dense_output=True) # Sample last 50 cycles after transient T = 2 * np.pi / omega_drive times = np.arange(250, 300, T) sampled = sol.sol(times) thetas = (sampled[0] + np.pi) % (2 * np.pi) - np.pi theta_samples.append(thetas) # Plot bifurcation diagram plt.figure(figsize=(10, 6)) for i, A_val in enumerate(A_values): plt.plot([A_val]*len(theta_samples[i]), theta_samples[i], ',k') plt.xlabel('Driving Amplitude (A)') plt.ylabel('Angle (radians)') plt.title('Bifurcation Diagram') plt.grid(True) plt.show() The diagram shows stable periodic orbits, period doubling bifurcations, and transitions to chaos as \\( A \\) increases.","title":"Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#summary","text":"These advanced visualizations help identify and classify dynamic regimes: Phase portraits : visualize continuous trajectories. Poincar\u00e9 sections : reduce dimensionality, reveal structure. Bifurcation diagrams : track system response to parameter changes. Together, they provide powerful insight into nonlinear dynamics and chaotic systems.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 1. Theoretical Foundation Newtonian Derivation of Kepler\u2019s Third Law for Circular Orbits To derive the relationship between the square of the orbital period \\( T \\) and the cube of the orbital radius \\( r \\) , we begin with Newton\u2019s law of universal gravitation and the centripetal force required for circular motion. Step 1: Gravitational Force According to Newton's law: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body (e.g., the Sun), - \\( m \\) is the mass of the orbiting body, - \\( r \\) is the orbital radius. Step 2: Centripetal Force For uniform circular motion: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Setting the gravitational force equal to the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and solving for \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] Step 3: Orbital Period The orbital period \\( T \\) is related to the orbital speed and circumference: \\[ T = \\frac{2\\pi r}{v} \\quad \\Rightarrow \\quad v = \\frac{2\\pi r}{T} \\] Substitute into the equation for \\( v^2 \\) : \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiply both sides by \\( r \\) : \\[ \\frac{4\\pi^2 r^3}{T^2} = G M \\] Now solve for \\( T^2 \\) : \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] Final Result This is Kepler\u2019s Third Law for circular orbits: \\[ T^2 \\propto r^3 \\] The constant of proportionality depends on the gravitational constant and the mass of the central body: \\[ T^2 = k r^3 \\quad \\text{where} \\quad k = \\frac{4\\pi^2}{G M} \\] This result explains why planets farther from the Sun take longer to orbit and provides a way to infer masses of celestial bodies from orbital data. 2. Implications for Astronomy Kepler\u2019s Third Law has profound implications for modern astronomy. Once the relationship \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] is established, it becomes a powerful tool for determining the mass of a central object or the distance to an orbiting body . 1. Calculating Mass from Orbital Motion By observing a satellite\u2019s orbital radius \\( r \\) and period \\( T \\) , we can calculate the mass \\( M \\) of the central object using: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] This method is commonly used to estimate: The mass of the Earth from Moon\u2019s orbit, The mass of the Sun from planetary orbits, The mass of exoplanet host stars . 2. Determining Orbital Radius If the mass \\( M \\) of the central body is known (e.g., from spectroscopy), we can rearrange Kepler\u2019s Law to compute the orbital radius: \\[ r = \\left( \\frac{G M T^2}{4\\pi^2} \\right)^{1/3} \\] This is used in: Satellite orbit design (e.g., geostationary satellites), Calculating the distance between binary stars, Estimating distances in planetary systems. 3. Astronomical Units and Simplified Forms In the Solar System, if we express: - \\( T \\) in Earth years, - \\( r \\) in astronomical units (AU), - \\( M \\) in solar masses, then the proportionality constant becomes 1: \\[ T^2 = r^3 \\] This simplification is frequently used in exoplanet detection , where observational data provides \\( T \\) , and \\( r \\) is inferred under this assumption. Summary Kepler\u2019s Third Law serves as: A cornerstone for measuring planetary systems , A practical method for estimating masses and distances , A theoretical link between Newtonian gravity and orbital dynamics . 3. Real-World Examples Kepler\u2019s Third Law can be directly applied to real celestial systems. Below are classic examples demonstrating its use. 1. The Moon\u2019s Orbit Around Earth Orbital radius: \\( r \\approx 3.84 \\times 10^8 \\) meters Orbital period: \\( T \\approx 27.3 \\) days \\( \\approx 2.36 \\times 10^6 \\) seconds Using: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] we can estimate Earth\u2019s mass: \\[ M \\approx \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{(6.674 \\times 10^{-11})(2.36 \\times 10^6)^2} \\approx 5.97 \\times 10^{24} \\text{ kg} \\] \u2705 Matches accepted value for Earth\u2019s mass. 2. Geostationary Satellite A geostationary satellite orbits Earth once per sidereal day: \\( T = 86,164 \\) seconds \\( M_{\\text{Earth}} = 5.97 \\times 10^{24} \\text{ kg} \\) Solving for \\( r \\) : \\[ r = \\left( \\frac{G M T^2}{4\\pi^2} \\right)^{1/3} \\] \\[ r \\approx \\left( \\frac{(6.674 \\times 10^{-11})(5.97 \\times 10^{24})(86164)^2}{4\\pi^2} \\right)^{1/3} \\approx 4.22 \\times 10^7 \\text{ m} \\] \u2705 This is approximately 35,786 km above Earth's surface \u2014 the correct altitude for geostationary orbit. 3. Planets in the Solar System Using AU and years: Earth's orbit: \\( r = 1 \\) AU, \\( T = 1 \\) year Mars: \\( r \\approx 1.52 \\) AU \\[ T^2 = r^3 \\quad \\Rightarrow \\quad T_{\\text{Mars}} = \\sqrt{(1.52)^3} \\approx 1.88 \\text{ years} \\] \u2705 Matches the known orbital period of Mars. 4. Exoplanets Kepler\u2019s Third Law is routinely applied in detecting exoplanets: Transit timing gives \\( T \\) Stellar mass \\( M \\) known from spectral data \\( r \\) inferred via: \\[ r = \\left( \\frac{G M T^2}{4\\pi^2} \\right)^{1/3} \\] This helps determine habitability zones , orbital stability , and even potential moons. Summary Kepler\u2019s Law is essential in: Satellite design and spaceflight, Measuring celestial masses, Understanding orbital dynamics from Earth to exoplanetary systems. 4. Implementation To verify Kepler\u2019s Third Law numerically, we simulate circular orbits of varying radii around a central mass and calculate the orbital periods for each case. Assumptions Circular, two-body orbits Central mass (e.g., the Sun): \\( M = 1.989 \\times 10^{30} \\text{ kg} \\) Only gravity provides the centripetal force Units: SI (meters, kilograms, seconds) Python Code import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 1.989e30 # mass of central body (Sun) # Orbital radii from 0.2 to 5 AU (converted to meters) AU = 1.496e11 radii_au = np.linspace(0.2, 5, 100) radii_m = radii_au * AU # Calculate periods using T = 2\u03c0 * sqrt(r^3 / GM) periods_s = 2 * np.pi * np.sqrt(radii_m**3 / (G * M)) periods_yr = periods_s / (60 * 60 * 24 * 365.25) # convert to years # Plot T^2 vs r^3 T_squared = periods_yr**2 r_cubed = radii_au**3 plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label='Simulated data', color='navy') plt.xlabel('$r^3$ (AU\u00b3)') plt.ylabel('$T^2$ (years\u00b2)') plt.title('Verification of Kepler\u2019s Third Law') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Interpretation According to Kepler\u2019s Third Law, the relationship: \\[ T^2 = k r^3 \\] should produce a straight line when plotting \\( T^2 \\) versus \\( r^3 \\) . The resulting graph confirms a linear relationship \u2014 verifying Kepler\u2019s Law in the circular orbit case. Next Steps Try fitting a linear regression to estimate the constant \\( k \\) . Extend the simulation to include elliptical orbits using numerical integration. Visualize orbits using position updates (x, y) for better understanding of orbital paths. 5. Discussion: Beyond Circular Orbits Kepler\u2019s Third Law is exact only for circular orbits under the assumption of a point mass and no perturbations. However, it can be generalized to: 1. Elliptical Orbits For elliptical orbits, the law still holds if we replace the orbital radius \\( r \\) with the semi-major axis \\( a \\) : \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] This version applies to: Planets in the Solar System (e.g., Earth, Mars), Moons and satellites in non-circular trajectories, Binary star systems. \u2705 This form is still widely used in astrophysics. 2. Multi-body Systems In real systems, additional bodies influence motion: Jupiter perturbs asteroid orbits. The Moon\u2019s orbit is affected by the Sun (three-body dynamics). Exoplanet systems show resonance and chaos due to gravitational interactions. While Kepler\u2019s Law provides a starting point, numerical simulation is essential for precision modeling in multi-body systems. 3. Mass Distribution and Relativity If the central mass is not a point (e.g., a planet with uneven mass), corrections are needed. In strong gravitational fields, General Relativity replaces Newtonian gravity \u2014 leading to corrections like orbital precession (e.g., Mercury). 4. Space Missions and Orbit Design Kepler\u2019s Law is foundational for: Launching satellites into desired orbits, Predicting planetary positions for interplanetary transfers (e.g., Hohmann transfers), Estimating fuel usage and timing for maneuvers. Summary Kepler\u2019s Third Law: Remains a fundamental relationship in celestial mechanics, Can be generalized to elliptical orbits using semi-major axis, Requires refinement for real-world accuracy (perturbations, relativity, non-uniform mass). It is both an elegant mathematical law and a practical tool for engineers, astronomers, and mission designers.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtonian-derivation-of-keplers-third-law-for-circular-orbits","text":"To derive the relationship between the square of the orbital period \\( T \\) and the cube of the orbital radius \\( r \\) , we begin with Newton\u2019s law of universal gravitation and the centripetal force required for circular motion.","title":"Newtonian Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-gravitational-force","text":"According to Newton's law: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body (e.g., the Sun), - \\( m \\) is the mass of the orbiting body, - \\( r \\) is the orbital radius.","title":"Step 1: Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-centripetal-force","text":"For uniform circular motion: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Setting the gravitational force equal to the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and solving for \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\]","title":"Step 2: Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-3-orbital-period","text":"The orbital period \\( T \\) is related to the orbital speed and circumference: \\[ T = \\frac{2\\pi r}{v} \\quad \\Rightarrow \\quad v = \\frac{2\\pi r}{T} \\] Substitute into the equation for \\( v^2 \\) : \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] \\[ \\frac{4\\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiply both sides by \\( r \\) : \\[ \\frac{4\\pi^2 r^3}{T^2} = G M \\] Now solve for \\( T^2 \\) : \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\]","title":"Step 3: Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-result","text":"This is Kepler\u2019s Third Law for circular orbits: \\[ T^2 \\propto r^3 \\] The constant of proportionality depends on the gravitational constant and the mass of the central body: \\[ T^2 = k r^3 \\quad \\text{where} \\quad k = \\frac{4\\pi^2}{G M} \\] This result explains why planets farther from the Sun take longer to orbit and provides a way to infer masses of celestial bodies from orbital data.","title":"Final Result"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Kepler\u2019s Third Law has profound implications for modern astronomy. Once the relationship \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] is established, it becomes a powerful tool for determining the mass of a central object or the distance to an orbiting body .","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-calculating-mass-from-orbital-motion","text":"By observing a satellite\u2019s orbital radius \\( r \\) and period \\( T \\) , we can calculate the mass \\( M \\) of the central object using: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] This method is commonly used to estimate: The mass of the Earth from Moon\u2019s orbit, The mass of the Sun from planetary orbits, The mass of exoplanet host stars .","title":"1. Calculating Mass from Orbital Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-determining-orbital-radius","text":"If the mass \\( M \\) of the central body is known (e.g., from spectroscopy), we can rearrange Kepler\u2019s Law to compute the orbital radius: \\[ r = \\left( \\frac{G M T^2}{4\\pi^2} \\right)^{1/3} \\] This is used in: Satellite orbit design (e.g., geostationary satellites), Calculating the distance between binary stars, Estimating distances in planetary systems.","title":"2. Determining Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-astronomical-units-and-simplified-forms","text":"In the Solar System, if we express: - \\( T \\) in Earth years, - \\( r \\) in astronomical units (AU), - \\( M \\) in solar masses, then the proportionality constant becomes 1: \\[ T^2 = r^3 \\] This simplification is frequently used in exoplanet detection , where observational data provides \\( T \\) , and \\( r \\) is inferred under this assumption.","title":"3. Astronomical Units and Simplified Forms"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"Kepler\u2019s Third Law serves as: A cornerstone for measuring planetary systems , A practical method for estimating masses and distances , A theoretical link between Newtonian gravity and orbital dynamics .","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"Kepler\u2019s Third Law can be directly applied to real celestial systems. Below are classic examples demonstrating its use.","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-the-moons-orbit-around-earth","text":"Orbital radius: \\( r \\approx 3.84 \\times 10^8 \\) meters Orbital period: \\( T \\approx 27.3 \\) days \\( \\approx 2.36 \\times 10^6 \\) seconds Using: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] we can estimate Earth\u2019s mass: \\[ M \\approx \\frac{4\\pi^2 (3.84 \\times 10^8)^3}{(6.674 \\times 10^{-11})(2.36 \\times 10^6)^2} \\approx 5.97 \\times 10^{24} \\text{ kg} \\] \u2705 Matches accepted value for Earth\u2019s mass.","title":"1. The Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-geostationary-satellite","text":"A geostationary satellite orbits Earth once per sidereal day: \\( T = 86,164 \\) seconds \\( M_{\\text{Earth}} = 5.97 \\times 10^{24} \\text{ kg} \\) Solving for \\( r \\) : \\[ r = \\left( \\frac{G M T^2}{4\\pi^2} \\right)^{1/3} \\] \\[ r \\approx \\left( \\frac{(6.674 \\times 10^{-11})(5.97 \\times 10^{24})(86164)^2}{4\\pi^2} \\right)^{1/3} \\approx 4.22 \\times 10^7 \\text{ m} \\] \u2705 This is approximately 35,786 km above Earth's surface \u2014 the correct altitude for geostationary orbit.","title":"2. Geostationary Satellite"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-planets-in-the-solar-system","text":"Using AU and years: Earth's orbit: \\( r = 1 \\) AU, \\( T = 1 \\) year Mars: \\( r \\approx 1.52 \\) AU \\[ T^2 = r^3 \\quad \\Rightarrow \\quad T_{\\text{Mars}} = \\sqrt{(1.52)^3} \\approx 1.88 \\text{ years} \\] \u2705 Matches the known orbital period of Mars.","title":"3. Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-exoplanets","text":"Kepler\u2019s Third Law is routinely applied in detecting exoplanets: Transit timing gives \\( T \\) Stellar mass \\( M \\) known from spectral data \\( r \\) inferred via: \\[ r = \\left( \\frac{G M T^2}{4\\pi^2} \\right)^{1/3} \\] This helps determine habitability zones , orbital stability , and even potential moons.","title":"4. Exoplanets"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary_1","text":"Kepler\u2019s Law is essential in: Satellite design and spaceflight, Measuring celestial masses, Understanding orbital dynamics from Earth to exoplanetary systems.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-implementation","text":"To verify Kepler\u2019s Third Law numerically, we simulate circular orbits of varying radii around a central mass and calculate the orbital periods for each case.","title":"4. Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#assumptions","text":"Circular, two-body orbits Central mass (e.g., the Sun): \\( M = 1.989 \\times 10^{30} \\text{ kg} \\) Only gravity provides the centripetal force Units: SI (meters, kilograms, seconds)","title":"Assumptions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 1.989e30 # mass of central body (Sun) # Orbital radii from 0.2 to 5 AU (converted to meters) AU = 1.496e11 radii_au = np.linspace(0.2, 5, 100) radii_m = radii_au * AU # Calculate periods using T = 2\u03c0 * sqrt(r^3 / GM) periods_s = 2 * np.pi * np.sqrt(radii_m**3 / (G * M)) periods_yr = periods_s / (60 * 60 * 24 * 365.25) # convert to years # Plot T^2 vs r^3 T_squared = periods_yr**2 r_cubed = radii_au**3 plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label='Simulated data', color='navy') plt.xlabel('$r^3$ (AU\u00b3)') plt.ylabel('$T^2$ (years\u00b2)') plt.title('Verification of Kepler\u2019s Third Law') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_1/#interpretation","text":"According to Kepler\u2019s Third Law, the relationship: \\[ T^2 = k r^3 \\] should produce a straight line when plotting \\( T^2 \\) versus \\( r^3 \\) . The resulting graph confirms a linear relationship \u2014 verifying Kepler\u2019s Law in the circular orbit case.","title":"Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#next-steps","text":"Try fitting a linear regression to estimate the constant \\( k \\) . Extend the simulation to include elliptical orbits using numerical integration. Visualize orbits using position updates (x, y) for better understanding of orbital paths.","title":"Next Steps"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-discussion-beyond-circular-orbits","text":"Kepler\u2019s Third Law is exact only for circular orbits under the assumption of a point mass and no perturbations. However, it can be generalized to:","title":"5. Discussion: Beyond Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-elliptical-orbits","text":"For elliptical orbits, the law still holds if we replace the orbital radius \\( r \\) with the semi-major axis \\( a \\) : \\[ T^2 = \\frac{4\\pi^2}{G M} a^3 \\] This version applies to: Planets in the Solar System (e.g., Earth, Mars), Moons and satellites in non-circular trajectories, Binary star systems. \u2705 This form is still widely used in astrophysics.","title":"1. Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-multi-body-systems","text":"In real systems, additional bodies influence motion: Jupiter perturbs asteroid orbits. The Moon\u2019s orbit is affected by the Sun (three-body dynamics). Exoplanet systems show resonance and chaos due to gravitational interactions. While Kepler\u2019s Law provides a starting point, numerical simulation is essential for precision modeling in multi-body systems.","title":"2. Multi-body Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-mass-distribution-and-relativity","text":"If the central mass is not a point (e.g., a planet with uneven mass), corrections are needed. In strong gravitational fields, General Relativity replaces Newtonian gravity \u2014 leading to corrections like orbital precession (e.g., Mercury).","title":"3. Mass Distribution and Relativity"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-space-missions-and-orbit-design","text":"Kepler\u2019s Law is foundational for: Launching satellites into desired orbits, Predicting planetary positions for interplanetary transfers (e.g., Hohmann transfers), Estimating fuel usage and timing for maneuvers.","title":"4. Space Missions and Orbit Design"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary_2","text":"Kepler\u2019s Third Law: Remains a fundamental relationship in celestial mechanics, Can be generalized to elliptical orbits using semi-major axis, Requires refinement for real-world accuracy (perturbations, relativity, non-uniform mass). It is both an elegant mathematical law and a practical tool for engineers, astronomers, and mission designers.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 1. Theoretical Foundation Cosmic velocities define the minimum speeds required to achieve specific goals in gravitational systems \u2014 from stable orbit to escaping the Solar System. First Cosmic Velocity ( \\( v_1 \\) ) \u2013 Orbital Velocity This is the minimum horizontal velocity required to maintain a stable circular orbit near the surface of a celestial body. \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] \\( G \\) \u2014 gravitational constant \\( M \\) \u2014 mass of the celestial body \\( r \\) \u2014 orbital radius (typically the radius of the planet for low Earth orbit) \u2705 A satellite launched at this speed will remain in free fall around the planet. Second Cosmic Velocity ( \\( v_2 \\) ) \u2013 Escape Velocity This is the minimum speed required to break free from the gravitational pull of a celestial body without further propulsion. \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} = \\sqrt{2} \\cdot v_1 \\] This velocity allows an object to reach infinity with zero final velocity . Used for missions leaving Earth toward the Moon, Mars, etc. \u2705 The spacecraft overcomes gravitational binding energy. Third Cosmic Velocity ( \\( v_3 \\) ) \u2013 Interstellar Escape Velocity This is the minimum speed required to leave the entire Solar System from Earth\u2019s orbit, overcoming the Sun\u2019s gravitational field. Assuming a starting point at Earth's orbit (neglecting Earth's own gravity): \\[ v_3 = \\sqrt{\\frac{2 G M_{\\odot}}{r_{\\text{Earth}}}} \\] \\( M_{\\odot} \\) \u2014 mass of the Sun \\( r_{\\text{Earth}} \\) \u2014 Earth's orbital radius around the Sun To launch from Earth\u2019s surface and escape the Solar System, both Earth\u2019s gravity and orbital motion must be taken into account: \\[ v_3^{\\text{total}} = \\sqrt{v_{2,\\text{Earth}}^2 + v_3^2 - 2 v_{1,\\text{Earth}} v_3 \\cos(\\theta)} \\] \u2705 Often achieved through gravity assists and deep-space propulsion. Summary Velocity Meaning Formula \\( v_1 \\) Circular orbital velocity \\( \\sqrt{GM/r} \\) \\( v_2 \\) Escape from planet \\( \\sqrt{2GM/r} \\) \\( v_3 \\) Escape from star system \\( \\sqrt{2GM_{\\odot}/r} \\) These velocities form the foundation of orbital mechanics and are critical for mission planning, satellite deployment, and interplanetary navigation. 2. Mathematical Derivations and Dependencies The first, second, and third cosmic velocities are derived from Newton's law of universal gravitation and principles of conservation of energy . First Cosmic Velocity ( \\( v_1 \\) ) This is the orbital speed for a circular orbit just above the surface: From Newton\u2019s law of gravitation: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] From Newton's second law (centripetal force): \\[ F = \\frac{m v^2}{r} \\] Equating the forces: \\[ \\frac{G M m}{r^2} = \\frac{m v_1^2}{r} \\Rightarrow v_1 = \\sqrt{\\frac{G M}{r}} \\] Second Cosmic Velocity ( \\( v_2 \\) ) This is derived from energy conservation : \\[ \\text{Initial total energy} = \\text{Final total energy} \\] \\[ \\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0 \\Rightarrow v_2 = \\sqrt{\\frac{2 G M}{r}} = \\sqrt{2} \\cdot v_1 \\] Here: - The kinetic energy must exactly cancel the gravitational potential energy. - Final energy at infinity is zero. Third Cosmic Velocity ( \\( v_3 \\) ) To escape the Sun\u2019s gravity from Earth\u2019s orbit: \\[ E = \\frac{1}{2} m v_3^2 - \\frac{G M_{\\odot} m}{r_{\\text{Earth}}} = 0 \\Rightarrow v_3 = \\sqrt{\\frac{2 G M_{\\odot}}{r_{\\text{Earth}}}} \\] But if launched from Earth, must also overcome Earth\u2019s escape velocity \\( v_{2,\\text{Earth}} \\) . The actual total velocity depends on launch direction and existing orbital motion: \\[ v_3^{\\text{total}} = \\sqrt{v_2^2 + v_3^2 - 2 v_1 v_3 \\cos(\\theta)} \\] where: - \\( \\theta \\) is the angle between launch direction and Earth\u2019s orbital velocity vector. Parameter Dependencies Parameter Influence \\( M \\) \u2014 central mass All three velocities increase with mass \\( r \\) \u2014 orbital radius All velocities decrease with larger radius \\( G \\) \u2014 gravitational constant Appears in all expressions \\( \\theta \\) \u2014 launch angle (only for \\( v_3^{\\text{total}} \\) ) Affects net velocity due to vector addition These derivations form the basis for calculating required launch speeds, designing trajectories, and estimating fuel needs in orbital mechanics. 3. Calculations and Visualizations To compare the first, second, and third cosmic velocities across celestial bodies, we calculate them for: Earth Moon Mars Jupiter Constants Body Radius \\( r \\) (m) Mass \\( M \\) (kg) Earth \\( 6.371 \\times 10^6 \\) \\( 5.972 \\times 10^{24} \\) Moon \\( 1.737 \\times 10^6 \\) \\( 7.342 \\times 10^{22} \\) Mars \\( 3.390 \\times 10^6 \\) \\( 6.417 \\times 10^{23} \\) Jupiter \\( 6.991 \\times 10^7 \\) \\( 1.898 \\times 10^{27} \\) Python Code import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # Data: name, radius (m), mass (kg) bodies = { \"Earth\": {\"r\": 6.371e6, \"M\": 5.972e24}, \"Moon\": {\"r\": 1.737e6, \"M\": 7.342e22}, \"Mars\": {\"r\": 3.390e6, \"M\": 6.417e23}, \"Jupiter\": {\"r\": 6.991e7, \"M\": 1.898e27} } # Prepare results results = [] for name, data in bodies.items(): r = data[\"r\"] M = data[\"M\"] v1 = np.sqrt(G * M / r) # First cosmic velocity v2 = np.sqrt(2) * v1 # Escape velocity results.append((name, v1, v2)) # Plotting labels = [r[0] for r in results] v1_vals = [r[1] / 1000 for r in results] # km/s v2_vals = [r[2] / 1000 for r in results] # km/s x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_vals, width, label='First Cosmic Velocity (v\u2081)') plt.bar(x + width/2, v2_vals, width, label='Second Cosmic Velocity (v\u2082)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Different Celestial Bodies') plt.xticks(x, labels) plt.legend() plt.grid(True) plt.tight_layout() plt.show() Example Results (rounded) Body \\( v_1 \\) (km/s) \\( v_2 \\) (km/s) Earth ~7.91 ~11.2 Moon ~1.68 ~2.38 Mars ~3.55 ~5.03 Jupiter ~42.1 ~59.5 Observations Jupiter requires the highest velocities due to its immense mass. The Moon requires the least velocity \u2014 ideal for training and early missions. Escape velocity is always \\( \\sqrt{2} \\) times the orbital velocity for a given body. These values are fundamental in planning rocket launches, satellite deployment, and interplanetary travel. 4. Application in Space Exploration Understanding and applying the first, second, and third cosmic velocities is fundamental to spaceflight and interplanetary mission design. 1. First Cosmic Velocity \u2013 Stable Orbit Used to place satellites into low Earth orbit (LEO) , geostationary orbit , or planetary orbit : Example: The International Space Station travels at approximately 7.66 km/s \u2014 close to Earth\u2019s first cosmic velocity. Application: Communication, weather, GPS, and Earth-observation satellites. 2. Second Cosmic Velocity \u2013 Escape from Planet Used when launching interplanetary missions (e.g. Mars rovers, lunar landers): Example: The Apollo missions used Saturn V to reach speeds >11.2 km/s to escape Earth\u2019s gravity. Application: Missions to the Moon, Mars, and beyond must exceed \\( v_2 \\) to leave Earth's gravitational field. 3. Third Cosmic Velocity \u2013 Escape the Solar System Used in missions that aim to leave the Sun\u2019s gravitational influence : Example: Voyager 1 reached ~16.6 km/s and is now in interstellar space \u2014 the first human-made object to achieve this. Achieved through: Gravity assists (slingshot maneuvers using planets) rather than direct launch at \\( v_3 \\) . Combined Considerations Mission Type Required Velocity LEO Satellite \\( v_1 \\) (e.g., 7.9 km/s) Lunar / Interplanetary \\( > v_2 \\) (e.g., 11.2+ km/s) Interstellar Probe \\( \\geq v_3 \\) from Earth\u2019s orbit For real missions, engineers account for atmosphere, rotation, inclination, planetary motion, and fuel efficiency \u2014 but cosmic velocities serve as essential baselines. Summary \\( v_1 \\) defines orbital mechanics and satellite dynamics. \\( v_2 \\) is critical for reaching the Moon, Mars, and other planets. \\( v_3 \\) underpins our journey into deep space. These velocities help bridge theory and practice in astrodynamics , launch planning , and interstellar exploration .","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-foundation","text":"Cosmic velocities define the minimum speeds required to achieve specific goals in gravitational systems \u2014 from stable orbit to escaping the Solar System.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1-orbital-velocity","text":"This is the minimum horizontal velocity required to maintain a stable circular orbit near the surface of a celestial body. \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] \\( G \\) \u2014 gravitational constant \\( M \\) \u2014 mass of the celestial body \\( r \\) \u2014 orbital radius (typically the radius of the planet for low Earth orbit) \u2705 A satellite launched at this speed will remain in free fall around the planet.","title":"First Cosmic Velocity (\\( v_1 \\)) \u2013 Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2-escape-velocity","text":"This is the minimum speed required to break free from the gravitational pull of a celestial body without further propulsion. \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} = \\sqrt{2} \\cdot v_1 \\] This velocity allows an object to reach infinity with zero final velocity . Used for missions leaving Earth toward the Moon, Mars, etc. \u2705 The spacecraft overcomes gravitational binding energy.","title":"Second Cosmic Velocity (\\( v_2 \\)) \u2013 Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3-interstellar-escape-velocity","text":"This is the minimum speed required to leave the entire Solar System from Earth\u2019s orbit, overcoming the Sun\u2019s gravitational field. Assuming a starting point at Earth's orbit (neglecting Earth's own gravity): \\[ v_3 = \\sqrt{\\frac{2 G M_{\\odot}}{r_{\\text{Earth}}}} \\] \\( M_{\\odot} \\) \u2014 mass of the Sun \\( r_{\\text{Earth}} \\) \u2014 Earth's orbital radius around the Sun To launch from Earth\u2019s surface and escape the Solar System, both Earth\u2019s gravity and orbital motion must be taken into account: \\[ v_3^{\\text{total}} = \\sqrt{v_{2,\\text{Earth}}^2 + v_3^2 - 2 v_{1,\\text{Earth}} v_3 \\cos(\\theta)} \\] \u2705 Often achieved through gravity assists and deep-space propulsion.","title":"Third Cosmic Velocity (\\( v_3 \\)) \u2013 Interstellar Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"Velocity Meaning Formula \\( v_1 \\) Circular orbital velocity \\( \\sqrt{GM/r} \\) \\( v_2 \\) Escape from planet \\( \\sqrt{2GM/r} \\) \\( v_3 \\) Escape from star system \\( \\sqrt{2GM_{\\odot}/r} \\) These velocities form the foundation of orbital mechanics and are critical for mission planning, satellite deployment, and interplanetary navigation.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations-and-dependencies","text":"The first, second, and third cosmic velocities are derived from Newton's law of universal gravitation and principles of conservation of energy .","title":"2. Mathematical Derivations and Dependencies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"This is the orbital speed for a circular orbit just above the surface: From Newton\u2019s law of gravitation: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] From Newton's second law (centripetal force): \\[ F = \\frac{m v^2}{r} \\] Equating the forces: \\[ \\frac{G M m}{r^2} = \\frac{m v_1^2}{r} \\Rightarrow v_1 = \\sqrt{\\frac{G M}{r}} \\]","title":"First Cosmic Velocity (\\( v_1 \\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"This is derived from energy conservation : \\[ \\text{Initial total energy} = \\text{Final total energy} \\] \\[ \\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0 \\Rightarrow v_2 = \\sqrt{\\frac{2 G M}{r}} = \\sqrt{2} \\cdot v_1 \\] Here: - The kinetic energy must exactly cancel the gravitational potential energy. - Final energy at infinity is zero.","title":"Second Cosmic Velocity (\\( v_2 \\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"To escape the Sun\u2019s gravity from Earth\u2019s orbit: \\[ E = \\frac{1}{2} m v_3^2 - \\frac{G M_{\\odot} m}{r_{\\text{Earth}}} = 0 \\Rightarrow v_3 = \\sqrt{\\frac{2 G M_{\\odot}}{r_{\\text{Earth}}}} \\] But if launched from Earth, must also overcome Earth\u2019s escape velocity \\( v_{2,\\text{Earth}} \\) . The actual total velocity depends on launch direction and existing orbital motion: \\[ v_3^{\\text{total}} = \\sqrt{v_2^2 + v_3^2 - 2 v_1 v_3 \\cos(\\theta)} \\] where: - \\( \\theta \\) is the angle between launch direction and Earth\u2019s orbital velocity vector.","title":"Third Cosmic Velocity (\\( v_3 \\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameter-dependencies","text":"Parameter Influence \\( M \\) \u2014 central mass All three velocities increase with mass \\( r \\) \u2014 orbital radius All velocities decrease with larger radius \\( G \\) \u2014 gravitational constant Appears in all expressions \\( \\theta \\) \u2014 launch angle (only for \\( v_3^{\\text{total}} \\) ) Affects net velocity due to vector addition These derivations form the basis for calculating required launch speeds, designing trajectories, and estimating fuel needs in orbital mechanics.","title":"Parameter Dependencies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculations-and-visualizations","text":"To compare the first, second, and third cosmic velocities across celestial bodies, we calculate them for: Earth Moon Mars Jupiter","title":"3. Calculations and Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants","text":"Body Radius \\( r \\) (m) Mass \\( M \\) (kg) Earth \\( 6.371 \\times 10^6 \\) \\( 5.972 \\times 10^{24} \\) Moon \\( 1.737 \\times 10^6 \\) \\( 7.342 \\times 10^{22} \\) Mars \\( 3.390 \\times 10^6 \\) \\( 6.417 \\times 10^{23} \\) Jupiter \\( 6.991 \\times 10^7 \\) \\( 1.898 \\times 10^{27} \\)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # Data: name, radius (m), mass (kg) bodies = { \"Earth\": {\"r\": 6.371e6, \"M\": 5.972e24}, \"Moon\": {\"r\": 1.737e6, \"M\": 7.342e22}, \"Mars\": {\"r\": 3.390e6, \"M\": 6.417e23}, \"Jupiter\": {\"r\": 6.991e7, \"M\": 1.898e27} } # Prepare results results = [] for name, data in bodies.items(): r = data[\"r\"] M = data[\"M\"] v1 = np.sqrt(G * M / r) # First cosmic velocity v2 = np.sqrt(2) * v1 # Escape velocity results.append((name, v1, v2)) # Plotting labels = [r[0] for r in results] v1_vals = [r[1] / 1000 for r in results] # km/s v2_vals = [r[2] / 1000 for r in results] # km/s x = np.arange(len(labels)) width = 0.35 plt.figure(figsize=(10, 6)) plt.bar(x - width/2, v1_vals, width, label='First Cosmic Velocity (v\u2081)') plt.bar(x + width/2, v2_vals, width, label='Second Cosmic Velocity (v\u2082)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Different Celestial Bodies') plt.xticks(x, labels) plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_2/#example-results-rounded","text":"Body \\( v_1 \\) (km/s) \\( v_2 \\) (km/s) Earth ~7.91 ~11.2 Moon ~1.68 ~2.38 Mars ~3.55 ~5.03 Jupiter ~42.1 ~59.5","title":"Example Results (rounded)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#observations","text":"Jupiter requires the highest velocities due to its immense mass. The Moon requires the least velocity \u2014 ideal for training and early missions. Escape velocity is always \\( \\sqrt{2} \\) times the orbital velocity for a given body. These values are fundamental in planning rocket launches, satellite deployment, and interplanetary travel.","title":"Observations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-application-in-space-exploration","text":"Understanding and applying the first, second, and third cosmic velocities is fundamental to spaceflight and interplanetary mission design.","title":"4. Application in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-stable-orbit","text":"Used to place satellites into low Earth orbit (LEO) , geostationary orbit , or planetary orbit : Example: The International Space Station travels at approximately 7.66 km/s \u2014 close to Earth\u2019s first cosmic velocity. Application: Communication, weather, GPS, and Earth-observation satellites.","title":"1. First Cosmic Velocity \u2013 Stable Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-from-planet","text":"Used when launching interplanetary missions (e.g. Mars rovers, lunar landers): Example: The Apollo missions used Saturn V to reach speeds >11.2 km/s to escape Earth\u2019s gravity. Application: Missions to the Moon, Mars, and beyond must exceed \\( v_2 \\) to leave Earth's gravitational field.","title":"2. Second Cosmic Velocity \u2013 Escape from Planet"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-escape-the-solar-system","text":"Used in missions that aim to leave the Sun\u2019s gravitational influence : Example: Voyager 1 reached ~16.6 km/s and is now in interstellar space \u2014 the first human-made object to achieve this. Achieved through: Gravity assists (slingshot maneuvers using planets) rather than direct launch at \\( v_3 \\) .","title":"3. Third Cosmic Velocity \u2013 Escape the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_2/#combined-considerations","text":"Mission Type Required Velocity LEO Satellite \\( v_1 \\) (e.g., 7.9 km/s) Lunar / Interplanetary \\( > v_2 \\) (e.g., 11.2+ km/s) Interstellar Probe \\( \\geq v_3 \\) from Earth\u2019s orbit For real missions, engineers account for atmosphere, rotation, inclination, planetary motion, and fuel efficiency \u2014 but cosmic velocities serve as essential baselines.","title":"Combined Considerations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary_1","text":"\\( v_1 \\) defines orbital mechanics and satellite dynamics. \\( v_2 \\) is critical for reaching the Moon, Mars, and other planets. \\( v_3 \\) underpins our journey into deep space. These velocities help bridge theory and practice in astrodynamics , launch planning , and interstellar exploration .","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 1. Theoretical Foundation The trajectory of a freely released payload near Earth depends on its initial speed, direction, and altitude \u2014 all governed by Newtonian gravity and conservation laws. Classification of Trajectories The shape of the payload\u2019s orbit depends on its specific mechanical energy \\( \\varepsilon \\) : \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{G M}{r} \\] where: - \\( v \\) is the initial velocity of the payload, - \\( r \\) is the distance from Earth\u2019s center, - \\( G \\) is the gravitational constant, - \\( M \\) is Earth\u2019s mass. Types of Trajectories Trajectory Type Condition on \\( \\varepsilon \\) Shape Bound (orbital) \\( \\varepsilon < 0 \\) Elliptical Escape \\( \\varepsilon = 0 \\) Parabolic Unbound \\( \\varepsilon > 0 \\) Hyperbolic Elliptical : Object is captured by Earth and follows a closed orbit. Parabolic : Object escapes Earth with exactly zero residual speed at infinity. Hyperbolic : Object escapes with non-zero speed \u2014 e.g., interplanetary or interstellar ejection. Relation to Orbital Velocity Let \\( v_1 = \\sqrt{\\frac{G M}{r}} \\) \u2014 the circular orbital velocity. Then: If \\( v < v_1 \\) : suborbital fall back to Earth If \\( v = v_1 \\) : circular orbit If \\( v_1 < v < v_2 \\) : elliptical orbit If \\( v = v_2 = \\sqrt{2} v_1 \\) : parabolic escape If \\( v > v_2 \\) : hyperbolic trajectory Orbital Equation (Polar Form) The general conic section equation for motion under gravity: \\[ r(\\theta) = \\frac{p}{1 + e \\cos(\\theta)} \\] where: - \\( p \\) is the semi-latus rectum, - \\( e \\) is the orbital eccentricity: - \\( e = 0 \\) : circle - \\( 0 < e < 1 \\) : ellipse - \\( e = 1 \\) : parabola - \\( e > 1 \\) : hyperbola Summary The trajectory depends on initial velocity and position, and can be classified using: Mechanical energy \\( \\varepsilon \\) Orbital velocity thresholds \\( v_1 \\) , \\( v_2 \\) Orbital eccentricity \\( e \\) These parameters help predict whether a payload returns, stays in orbit, or escapes. 2. Numerical Simulation of Trajectories To predict the motion of a freely released payload under Earth's gravity, we numerically solve Newton\u2019s second law in a gravitational field: \\[ \\vec{a} = -\\frac{GM}{r^3} \\vec{r} \\] This system models orbital, suborbital, and escape trajectories in two dimensions. Initial Conditions Let the payload be released at an altitude of 300 km above Earth\u2019s surface with a specified velocity vector: Initial position: [ \\vec{r}_0 = [R + h, 0] ] where \\( R = 6.371 \\times 10^6 \\, \\text{m} \\) , \\( h = 3 \\times 10^5 \\, \\text{m} \\) Initial velocity (e.g. tangential): [ \\vec{v}_0 = [0, v] ] By varying \\( v \\) , we generate different trajectory types. Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Earth mass (kg) R = 6.371e6 # Earth radius (m) # Initial conditions h = 300e3 # Altitude (300 km) r0 = np.array([R + h, 0]) # Position vector v0 = np.array([0, 7700]) # Velocity vector (change this!) # Define the system of ODEs def two_body(t, y): rx, ry, vx, vy = y r = np.sqrt(rx**2 + ry**2) ax = -G * M * rx / r**3 ay = -G * M * ry / r**3 return [vx, vy, ax, ay] # Solve t_span = (0, 10000) y0 = np.concatenate((r0, v0)) # Combine position and velocity t_eval = np.linspace(*t_span, 2000) sol = solve_ivp(two_body, t_span, y0, t_eval=t_eval, rtol=1e-8) # Extract x, y = sol.y[0] / 1e3, sol.y[1] / 1e3 # Convert to km # Plot plt.figure(figsize=(7, 7)) plt.plot(x, y, label='Payload Trajectory') earth = plt.Circle((0, 0), R / 1e3, color='skyblue', alpha=0.6, label='Earth') plt.gca().add_patch(earth) plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Trajectory of a Released Payload Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Interpreting Results 7700 m/s \u2192 close to circular orbit (first cosmic speed) >11200 m/s \u2192 escape trajectory (second cosmic speed) <7700 m/s \u2192 suborbital, will fall back to Earth You can also test: - Diagonal or retrograde velocities - Higher altitudes - Angle variation to simulate real payload drops Notes This model assumes vacuum and no atmosphere . For long simulations, numerical precision (e.g., rtol ) is critical. Extending to 3D or adding perturbations (e.g., Moon, drag) is possible in future work. By adjusting just the initial velocity, you can visualize orbit types and transitions from bound to unbound motion. 3. Discussion of Trajectory Outcomes The shape and outcome of a payload\u2019s trajectory depends on its initial speed , direction , and altitude . These parameters determine whether the object: returns to Earth (reentry), remains in orbit, escapes Earth\u2019s gravity (interplanetary transfer). Summary of Outcomes Initial Velocity \\( v \\) Resulting Trajectory Real-World Application \\( v < v_1 \\) Suborbital / ballistic Space tourism, ICBMs, reentry capsules \\( v = v_1 \\) Circular orbit Satellites (LEO, MEO, GEO), ISS \\( v_1 < v < v_2 \\) Elliptical orbit Transfer orbits, Molniya, GTO \\( v = v_2 \\) Parabolic (escape) Theoretical limit for escape trajectories \\( v > v_2 \\) Hyperbolic (unbound) Interplanetary probes, escape trajectories Practical Considerations Suborbital Trajectories : Common in early rocket tests and reusable spaceplanes (e.g., Blue Origin). Maximum altitude depends on velocity and release angle. Circular Orbits : Used for stable satellite operations (e.g., weather, GPS). Require continuous balancing of gravity and inertia. Elliptical Orbits : Used for transfers between altitudes or planets. Include perigee (closest point) and apogee (farthest point). Escape Trajectories : Enable payloads to leave Earth entirely. Example: New Horizons and Voyager missions. Hyperbolic Trajectories : Arise from excess velocity (e.g., gravity assist maneuvers). Used to leave not only Earth, but the Solar System. Role in Mission Planning Understanding trajectory types allows engineers to: Calculate required delta-v (velocity change), Select appropriate launch windows , Optimize fuel usage and transfer time . Numerical trajectory analysis is essential in orbital design, satellite deployment, and mission control. Visualization Suggestion Plotting trajectories with: - different initial speeds, - various angles of release, - altitude profiles, can reveal how tiny changes affect the outcome \u2014 reentry, orbit, or escape. 4. Simulation and Visualization Tool To explore how the trajectory of a released payload changes with different initial conditions, we build a flexible simulation tool. The user can set: Initial speed (in m/s), Direction angle (in degrees), Initial altitude (in km above Earth's surface). The script then computes and visualizes the trajectory using numerical integration. Python Code import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Earth mass (kg) R = 6.371e6 # Earth radius (m) def simulate_payload_trajectory(v0, angle_deg, altitude_km=300, duration=10000): # Initial position vector r0 = np.array([R + altitude_km * 1e3, 0]) # Initial velocity vector based on launch angle theta = np.radians(angle_deg) v0_vec = v0 * np.array([np.cos(theta), np.sin(theta)]) # Initial state: [x, y, vx, vy] y0 = np.concatenate((r0, v0_vec)) # Gravitational acceleration system def dynamics(t, y): rx, ry, vx, vy = y r = np.sqrt(rx**2 + ry**2) ax = -G * M * rx / r**3 ay = -G * M * ry / r**3 return [vx, vy, ax, ay] # Time configuration t_span = (0, duration) t_eval = np.linspace(*t_span, 3000) # Numerical integration sol = solve_ivp(dynamics, t_span, y0, t_eval=t_eval, rtol=1e-8) # Extract and convert to kilometers x_km = sol.y[0] / 1e3 y_km = sol.y[1] / 1e3 # Plot the trajectory plt.figure(figsize=(7, 7)) plt.plot(x_km, y_km, label=f'{v0/1000:.1f} km/s, {angle_deg}\u00b0') earth = plt.Circle((0, 0), R / 1e3, color='skyblue', alpha=0.5, label='Earth') plt.gca().add_patch(earth) plt.axis('equal') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Payload Trajectory Simulation') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Example Simulations Try these scenarios to explore different outcomes: # Suborbital reentry (will fall back) simulate_payload_trajectory(v0=6500, angle_deg=20) # Near-circular orbit simulate_payload_trajectory(v0=7800, angle_deg=0) # Elliptical orbit simulate_payload_trajectory(v0=9000, angle_deg=0) # Escape trajectory (hyperbolic) simulate_payload_trajectory(v0=11500, angle_deg=0) Parameters You Can Explore Parameter Effect v0 (m/s) Affects energy: determines fall/orbit/escape angle_deg Affects trajectory shape and altitude arc altitude_km Sets release height above Earth duration Controls how long the trajectory is computed This tool lets you visualize the exact path of a payload based on initial launch parameters \u2014 ideal for mission simulation, orbit design, and understanding gravitational motion. 5. Summary and Real-World Applications \u2705 What We Have Learned In this project, we explored how the trajectory of a freely released payload near Earth depends on: Initial velocity magnitude Release angle Altitude above Earth We classified motion using physical principles: Bound orbits : elliptical, circular Unbound trajectories : parabolic and hyperbolic escape Suborbital arcs : reentry paths Using numerical simulation, we verified how slight changes in initial conditions drastically affect the resulting path. \ud83d\udd2d Real-World Applications Understanding these trajectories is essential in: \ud83d\ude80 Satellite Deployment LEO, MEO, and GEO satellites require precise insertion into stable elliptical or circular orbits . Misaligned velocity \u2192 decay, reentry, or unintended orbits. \ud83c\udf11 Lunar and Planetary Missions To escape Earth and reach the Moon or Mars, payloads must reach escape velocity at proper angles and timing . This requires combining Earth escape and interplanetary injection accurately. \ud83c\udf0d Suborbital Flights and Reentry Space tourism (e.g., Blue Origin) and capsule reentry missions rely on controlled suborbital arcs . Understanding fall-back trajectories improves safety and fuel efficiency . \ud83d\udef0\ufe0f Orbit Design and Transfer Elliptical orbits used for: Transfer between altitudes (Hohmann transfer), Raising apogee/perigee, Phasing for satellite constellations. \ud83e\udde0 Space Education and Visualization Numerical tools help students and engineers visualize orbital mechanics intuitively. Enhances understanding of gravitational dynamics and mission planning. The ability to simulate and analyze orbital trajectories is not just academic \u2014 it\u2019s a vital part of real mission design in today\u2019s space industry.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-foundation","text":"The trajectory of a freely released payload near Earth depends on its initial speed, direction, and altitude \u2014 all governed by Newtonian gravity and conservation laws.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#classification-of-trajectories","text":"The shape of the payload\u2019s orbit depends on its specific mechanical energy \\( \\varepsilon \\) : \\[ \\varepsilon = \\frac{v^2}{2} - \\frac{G M}{r} \\] where: - \\( v \\) is the initial velocity of the payload, - \\( r \\) is the distance from Earth\u2019s center, - \\( G \\) is the gravitational constant, - \\( M \\) is Earth\u2019s mass.","title":"Classification of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Trajectory Type Condition on \\( \\varepsilon \\) Shape Bound (orbital) \\( \\varepsilon < 0 \\) Elliptical Escape \\( \\varepsilon = 0 \\) Parabolic Unbound \\( \\varepsilon > 0 \\) Hyperbolic Elliptical : Object is captured by Earth and follows a closed orbit. Parabolic : Object escapes Earth with exactly zero residual speed at infinity. Hyperbolic : Object escapes with non-zero speed \u2014 e.g., interplanetary or interstellar ejection.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#relation-to-orbital-velocity","text":"Let \\( v_1 = \\sqrt{\\frac{G M}{r}} \\) \u2014 the circular orbital velocity. Then: If \\( v < v_1 \\) : suborbital fall back to Earth If \\( v = v_1 \\) : circular orbit If \\( v_1 < v < v_2 \\) : elliptical orbit If \\( v = v_2 = \\sqrt{2} v_1 \\) : parabolic escape If \\( v > v_2 \\) : hyperbolic trajectory","title":"Relation to Orbital Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-equation-polar-form","text":"The general conic section equation for motion under gravity: \\[ r(\\theta) = \\frac{p}{1 + e \\cos(\\theta)} \\] where: - \\( p \\) is the semi-latus rectum, - \\( e \\) is the orbital eccentricity: - \\( e = 0 \\) : circle - \\( 0 < e < 1 \\) : ellipse - \\( e = 1 \\) : parabola - \\( e > 1 \\) : hyperbola","title":"Orbital Equation (Polar Form)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary","text":"The trajectory depends on initial velocity and position, and can be classified using: Mechanical energy \\( \\varepsilon \\) Orbital velocity thresholds \\( v_1 \\) , \\( v_2 \\) Orbital eccentricity \\( e \\) These parameters help predict whether a payload returns, stays in orbit, or escapes.","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-simulation-of-trajectories","text":"To predict the motion of a freely released payload under Earth's gravity, we numerically solve Newton\u2019s second law in a gravitational field: \\[ \\vec{a} = -\\frac{GM}{r^3} \\vec{r} \\] This system models orbital, suborbital, and escape trajectories in two dimensions.","title":"2. Numerical Simulation of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"Let the payload be released at an altitude of 300 km above Earth\u2019s surface with a specified velocity vector: Initial position: [ \\vec{r}_0 = [R + h, 0] ] where \\( R = 6.371 \\times 10^6 \\, \\text{m} \\) , \\( h = 3 \\times 10^5 \\, \\text{m} \\) Initial velocity (e.g. tangential): [ \\vec{v}_0 = [0, v] ] By varying \\( v \\) , we generate different trajectory types.","title":"Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Earth mass (kg) R = 6.371e6 # Earth radius (m) # Initial conditions h = 300e3 # Altitude (300 km) r0 = np.array([R + h, 0]) # Position vector v0 = np.array([0, 7700]) # Velocity vector (change this!) # Define the system of ODEs def two_body(t, y): rx, ry, vx, vy = y r = np.sqrt(rx**2 + ry**2) ax = -G * M * rx / r**3 ay = -G * M * ry / r**3 return [vx, vy, ax, ay] # Solve t_span = (0, 10000) y0 = np.concatenate((r0, v0)) # Combine position and velocity t_eval = np.linspace(*t_span, 2000) sol = solve_ivp(two_body, t_span, y0, t_eval=t_eval, rtol=1e-8) # Extract x, y = sol.y[0] / 1e3, sol.y[1] / 1e3 # Convert to km # Plot plt.figure(figsize=(7, 7)) plt.plot(x, y, label='Payload Trajectory') earth = plt.Circle((0, 0), R / 1e3, color='skyblue', alpha=0.6, label='Earth') plt.gca().add_patch(earth) plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Trajectory of a Released Payload Near Earth') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#interpreting-results","text":"7700 m/s \u2192 close to circular orbit (first cosmic speed) >11200 m/s \u2192 escape trajectory (second cosmic speed) <7700 m/s \u2192 suborbital, will fall back to Earth You can also test: - Diagonal or retrograde velocities - Higher altitudes - Angle variation to simulate real payload drops","title":"Interpreting Results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#notes","text":"This model assumes vacuum and no atmosphere . For long simulations, numerical precision (e.g., rtol ) is critical. Extending to 3D or adding perturbations (e.g., Moon, drag) is possible in future work. By adjusting just the initial velocity, you can visualize orbit types and transitions from bound to unbound motion.","title":"Notes"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-discussion-of-trajectory-outcomes","text":"The shape and outcome of a payload\u2019s trajectory depends on its initial speed , direction , and altitude . These parameters determine whether the object: returns to Earth (reentry), remains in orbit, escapes Earth\u2019s gravity (interplanetary transfer).","title":"3. Discussion of Trajectory Outcomes"},{"location":"1%20Physics/2%20Gravity/Problem_3/#summary-of-outcomes","text":"Initial Velocity \\( v \\) Resulting Trajectory Real-World Application \\( v < v_1 \\) Suborbital / ballistic Space tourism, ICBMs, reentry capsules \\( v = v_1 \\) Circular orbit Satellites (LEO, MEO, GEO), ISS \\( v_1 < v < v_2 \\) Elliptical orbit Transfer orbits, Molniya, GTO \\( v = v_2 \\) Parabolic (escape) Theoretical limit for escape trajectories \\( v > v_2 \\) Hyperbolic (unbound) Interplanetary probes, escape trajectories","title":"Summary of Outcomes"},{"location":"1%20Physics/2%20Gravity/Problem_3/#practical-considerations","text":"Suborbital Trajectories : Common in early rocket tests and reusable spaceplanes (e.g., Blue Origin). Maximum altitude depends on velocity and release angle. Circular Orbits : Used for stable satellite operations (e.g., weather, GPS). Require continuous balancing of gravity and inertia. Elliptical Orbits : Used for transfers between altitudes or planets. Include perigee (closest point) and apogee (farthest point). Escape Trajectories : Enable payloads to leave Earth entirely. Example: New Horizons and Voyager missions. Hyperbolic Trajectories : Arise from excess velocity (e.g., gravity assist maneuvers). Used to leave not only Earth, but the Solar System.","title":"Practical Considerations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#role-in-mission-planning","text":"Understanding trajectory types allows engineers to: Calculate required delta-v (velocity change), Select appropriate launch windows , Optimize fuel usage and transfer time . Numerical trajectory analysis is essential in orbital design, satellite deployment, and mission control.","title":"Role in Mission Planning"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualization-suggestion","text":"Plotting trajectories with: - different initial speeds, - various angles of release, - altitude profiles, can reveal how tiny changes affect the outcome \u2014 reentry, orbit, or escape.","title":"Visualization Suggestion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-simulation-and-visualization-tool","text":"To explore how the trajectory of a released payload changes with different initial conditions, we build a flexible simulation tool. The user can set: Initial speed (in m/s), Direction angle (in degrees), Initial altitude (in km above Earth's surface). The script then computes and visualizes the trajectory using numerical integration.","title":"4. Simulation and Visualization Tool"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code_1","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant M = 5.972e24 # Earth mass (kg) R = 6.371e6 # Earth radius (m) def simulate_payload_trajectory(v0, angle_deg, altitude_km=300, duration=10000): # Initial position vector r0 = np.array([R + altitude_km * 1e3, 0]) # Initial velocity vector based on launch angle theta = np.radians(angle_deg) v0_vec = v0 * np.array([np.cos(theta), np.sin(theta)]) # Initial state: [x, y, vx, vy] y0 = np.concatenate((r0, v0_vec)) # Gravitational acceleration system def dynamics(t, y): rx, ry, vx, vy = y r = np.sqrt(rx**2 + ry**2) ax = -G * M * rx / r**3 ay = -G * M * ry / r**3 return [vx, vy, ax, ay] # Time configuration t_span = (0, duration) t_eval = np.linspace(*t_span, 3000) # Numerical integration sol = solve_ivp(dynamics, t_span, y0, t_eval=t_eval, rtol=1e-8) # Extract and convert to kilometers x_km = sol.y[0] / 1e3 y_km = sol.y[1] / 1e3 # Plot the trajectory plt.figure(figsize=(7, 7)) plt.plot(x_km, y_km, label=f'{v0/1000:.1f} km/s, {angle_deg}\u00b0') earth = plt.Circle((0, 0), R / 1e3, color='skyblue', alpha=0.5, label='Earth') plt.gca().add_patch(earth) plt.axis('equal') plt.xlabel('x (km)') plt.ylabel('y (km)') plt.title('Payload Trajectory Simulation') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#example-simulations","text":"Try these scenarios to explore different outcomes: # Suborbital reentry (will fall back) simulate_payload_trajectory(v0=6500, angle_deg=20) # Near-circular orbit simulate_payload_trajectory(v0=7800, angle_deg=0) # Elliptical orbit simulate_payload_trajectory(v0=9000, angle_deg=0) # Escape trajectory (hyperbolic) simulate_payload_trajectory(v0=11500, angle_deg=0)","title":"Example Simulations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#parameters-you-can-explore","text":"Parameter Effect v0 (m/s) Affects energy: determines fall/orbit/escape angle_deg Affects trajectory shape and altitude arc altitude_km Sets release height above Earth duration Controls how long the trajectory is computed This tool lets you visualize the exact path of a payload based on initial launch parameters \u2014 ideal for mission simulation, orbit design, and understanding gravitational motion.","title":"Parameters You Can Explore"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-summary-and-real-world-applications","text":"","title":"5. Summary and Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#what-we-have-learned","text":"In this project, we explored how the trajectory of a freely released payload near Earth depends on: Initial velocity magnitude Release angle Altitude above Earth We classified motion using physical principles: Bound orbits : elliptical, circular Unbound trajectories : parabolic and hyperbolic escape Suborbital arcs : reentry paths Using numerical simulation, we verified how slight changes in initial conditions drastically affect the resulting path.","title":"\u2705 What We Have Learned"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Understanding these trajectories is essential in:","title":"\ud83d\udd2d Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#satellite-deployment","text":"LEO, MEO, and GEO satellites require precise insertion into stable elliptical or circular orbits . Misaligned velocity \u2192 decay, reentry, or unintended orbits.","title":"\ud83d\ude80 Satellite Deployment"},{"location":"1%20Physics/2%20Gravity/Problem_3/#lunar-and-planetary-missions","text":"To escape Earth and reach the Moon or Mars, payloads must reach escape velocity at proper angles and timing . This requires combining Earth escape and interplanetary injection accurately.","title":"\ud83c\udf11 Lunar and Planetary Missions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#suborbital-flights-and-reentry","text":"Space tourism (e.g., Blue Origin) and capsule reentry missions rely on controlled suborbital arcs . Understanding fall-back trajectories improves safety and fuel efficiency .","title":"\ud83c\udf0d Suborbital Flights and Reentry"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbit-design-and-transfer","text":"Elliptical orbits used for: Transfer between altitudes (Hohmann transfer), Raising apogee/perigee, Phasing for satellite constellations.","title":"\ud83d\udef0\ufe0f Orbit Design and Transfer"},{"location":"1%20Physics/2%20Gravity/Problem_3/#space-education-and-visualization","text":"Numerical tools help students and engineers visualize orbital mechanics intuitively. Enhances understanding of gravitational dynamics and mission planning. The ability to simulate and analyze orbital trajectories is not just academic \u2014 it\u2019s a vital part of real mission design in today\u2019s space industry.","title":"\ud83e\udde0 Space Education and Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 1. Theoretical Foundation When multiple circular waves are emitted from different point sources on a water surface, they overlap and form complex interference patterns . These patterns are governed by: The wave equation for each point source, The principle of superposition . Single Source Wave Equation A wave emitted by a point source located at \\( (x_0, y_0) \\) on the surface is given by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] where: - \\( \\eta(x, y, t) \\) is the displacement of the water surface, - \\( A \\) is the amplitude, - \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) is the distance from the source to point \\( (x, y) \\) , - \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, - \\( \\omega = 2\\pi f \\) is the angular frequency, - \\( \\phi \\) is the initial phase of the wave. We assume all waves are monochromatic , coherent , and have identical amplitude, frequency, and phase . Superposition of Waves If we place \\( N \\) identical sources at different positions \\( (x_i, y_i) \\) , the resulting displacement is the sum of displacements from each: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] This leads to constructive interference when wave crests align, and destructive interference when crests and troughs cancel each other. Symmetry and Patterns If the sources are placed at the vertices of a regular polygon , their symmetry will be reflected in the interference pattern: 3 sources \u2192 triangular symmetry 4 sources \u2192 square symmetry 5+ sources \u2192 complex radial patterns These symmetrical setups are useful for studying: Zones of maximum and minimum amplitude, Nodal lines (where waves cancel out), Phase alignment across space. Summary Concept Role Point wave equation Describes wave from one source Superposition Adds effects of all sources together Interference pattern Emerges from wave overlap (constructive/destructive) Regular polygon layout Introduces symmetry and periodicity to the system This theoretical base enables us to model and visualize wave interference patterns with clarity and control. 2. Polygon-Based Source Layout and Simulation Strategy To analyze interference patterns from multiple sources, we arrange \\( N \\) identical wave sources at the vertices of a regular polygon (triangle, square, pentagon, etc.). 1. Positioning Sources on a Polygon All sources are placed on a circle of radius \\( R \\) centered at the origin. The coordinates of each source \\( (x_i, y_i) \\) are: \\[ x_i = R \\cdot \\cos\\left( \\frac{2\\pi i}{N} \\right), \\quad y_i = R \\cdot \\sin\\left( \\frac{2\\pi i}{N} \\right), \\quad i = 0, 1, \\dots, N-1 \\] This ensures perfect rotational symmetry. 2. Grid of Observation Points We define a 2D grid of points \\( (x, y) \\) over a square region containing the polygon. At each point, we compute the total displacement: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t) \\] where \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from each source to the grid point. 3. Simulation Parameters You can vary: Parameter Effect \\( N \\) Number of sources (symmetry of the pattern) \\( R \\) Radius of the source circle \\( \\lambda \\) Wavelength of the wave \\( f \\) Frequency \\( A \\) Amplitude (optional: normalize to 1) Grid size Resolution of the visualization 4. Visualization Use a 2D color map to display the resulting wave amplitude or intensity at each point. Choose either: Snapshot in time (e.g., fixed \\( t = 0 \\) ) Animated sequence for evolving interference Summary Step Description Generate \\( N \\) source positions Based on regular polygon around center Compute wave contribution At each point, from each source Apply superposition Sum wave amplitudes (or intensities) Visualize pattern Use color maps to show constructive/destructive regions This strategy creates the foundation for generating visually rich and physically accurate wave interference simulations. 3. Python Simulation & Plotting We simulate the interference pattern by computing the superposition of waves from multiple point sources over a 2D grid. The code below supports: - Configurable number of sources, - Adjustable polygon radius, wavelength, and frequency, - Static snapshot visualization using a 2D color map. Python Code import numpy as np import matplotlib.pyplot as plt # Parameters N = 5 # Number of wave sources (e.g., 3=triangle, 4=square, 5=pentagon) R = 1.0 # Radius of the polygon (in meters) A = 1.0 # Wave amplitude lam = 0.5 # Wavelength (meters) f = 1.0 # Frequency (Hz) omega = 2 * np.pi * f k = 2 * np.pi / lam t = 0 # Snapshot time (seconds) # Grid for visualization grid_size = 500 x = np.linspace(-2, 2, grid_size) y = np.linspace(-2, 2, grid_size) X, Y = np.meshgrid(x, y) eta_total = np.zeros_like(X) # Generate source positions in regular polygon source_coords = [ (R * np.cos(2 * np.pi * i / N), R * np.sin(2 * np.pi * i / N)) for i in range(N) ] # Compute superposition of waves for (x0, y0) in source_coords: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # avoid division by 0 eta = (A / np.sqrt(r)) * np.cos(k * r - omega * t) eta_total += eta # Visualization plt.figure(figsize=(7, 6)) plt.imshow(eta_total, extent=[-2, 2, -2, 2], cmap='viridis', origin='lower') plt.colorbar(label='Displacement \u03b7(x, y, t)') plt.title(f'Interference Pattern: {N} Sources on Polygon') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.tight_layout() plt.show() How to Use Change these values to explore: Parameter Role N Number of sources (polygon type) R Polygon size (radius) lam Wavelength \u2014 controls spacing of fringes f Frequency \u2014 affects animation if implemented t Time snapshot \u2014 static or animated What This Shows Bright regions : constructive interference (amplified waves) Dark regions : destructive interference (cancellation) Fringes : result of path differences between wave sources You can extend this model to animations or interactive sliders using ipywidgets or matplotlib.animation . 4. Analysis and Interpretation The generated interference pattern reveals how waves interact based on their relative phase and source geometry. Key Features in the Pattern \u2795 Constructive Interference Occurs where waves from different sources arrive in phase , reinforcing each other: Appears as bright or elevated regions . Found along symmetry lines from source to center. Distance differences between sources equal to \\( n \\lambda \\) , where \\( n \\in \\mathbb{Z} \\) . \u2796 Destructive Interference Occurs where waves arrive out of phase , cancelling each other: Appears as dark regions or nodes . Wave amplitudes subtract and reduce the total displacement. Happens when path difference equals \\( (n + \\frac{1}{2})\\lambda \\) . Symmetry and Geometry The rotational symmetry of the polygon is reflected in the interference pattern. Triangle \u2192 3-fold symmetry. Square \u2192 4-fold. Pentagon \u2192 5-fold radial patterns. The number of radial arms or nodal lines increases with the number of sources. Physical Interpretation Feature Physical Meaning Sharp bright peaks Regions of high coherence, where waves align perfectly Concentric rings Result from uniform distance differences between pairs of sources Nodal lines Boundaries between constructive and destructive zones Complexity increases with \\( N \\) More interference paths, richer structure Applications This analysis is analogous to: Water tank experiments (real-life lab visuals) Optical interference (e.g., multiple-slit diffraction) Acoustic systems (speaker arrays, architectural acoustics) Quantum wavefunctions (interference in probability amplitudes) Interference patterns visually encode phase relationships and wave dynamics. By adjusting the number and arrangement of sources, we can design patterns with desired symmetry or cancellation zones \u2014 with applications from physics education to antenna design.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-foundation","text":"When multiple circular waves are emitted from different point sources on a water surface, they overlap and form complex interference patterns . These patterns are governed by: The wave equation for each point source, The principle of superposition .","title":"1. Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-source-wave-equation","text":"A wave emitted by a point source located at \\( (x_0, y_0) \\) on the surface is given by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos(kr - \\omega t + \\phi) \\] where: - \\( \\eta(x, y, t) \\) is the displacement of the water surface, - \\( A \\) is the amplitude, - \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) is the distance from the source to point \\( (x, y) \\) , - \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, - \\( \\omega = 2\\pi f \\) is the angular frequency, - \\( \\phi \\) is the initial phase of the wave. We assume all waves are monochromatic , coherent , and have identical amplitude, frequency, and phase .","title":"Single Source Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"If we place \\( N \\) identical sources at different positions \\( (x_i, y_i) \\) , the resulting displacement is the sum of displacements from each: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] This leads to constructive interference when wave crests align, and destructive interference when crests and troughs cancel each other.","title":"Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry-and-patterns","text":"If the sources are placed at the vertices of a regular polygon , their symmetry will be reflected in the interference pattern: 3 sources \u2192 triangular symmetry 4 sources \u2192 square symmetry 5+ sources \u2192 complex radial patterns These symmetrical setups are useful for studying: Zones of maximum and minimum amplitude, Nodal lines (where waves cancel out), Phase alignment across space.","title":"Symmetry and Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#summary","text":"Concept Role Point wave equation Describes wave from one source Superposition Adds effects of all sources together Interference pattern Emerges from wave overlap (constructive/destructive) Regular polygon layout Introduces symmetry and periodicity to the system This theoretical base enables us to model and visualize wave interference patterns with clarity and control.","title":"Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-polygon-based-source-layout-and-simulation-strategy","text":"To analyze interference patterns from multiple sources, we arrange \\( N \\) identical wave sources at the vertices of a regular polygon (triangle, square, pentagon, etc.).","title":"2. Polygon-Based Source Layout and Simulation Strategy"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-positioning-sources-on-a-polygon","text":"All sources are placed on a circle of radius \\( R \\) centered at the origin. The coordinates of each source \\( (x_i, y_i) \\) are: \\[ x_i = R \\cdot \\cos\\left( \\frac{2\\pi i}{N} \\right), \\quad y_i = R \\cdot \\sin\\left( \\frac{2\\pi i}{N} \\right), \\quad i = 0, 1, \\dots, N-1 \\] This ensures perfect rotational symmetry.","title":"1. Positioning Sources on a Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-grid-of-observation-points","text":"We define a 2D grid of points \\( (x, y) \\) over a square region containing the polygon. At each point, we compute the total displacement: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t) \\] where \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from each source to the grid point.","title":"2. Grid of Observation Points"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-simulation-parameters","text":"You can vary: Parameter Effect \\( N \\) Number of sources (symmetry of the pattern) \\( R \\) Radius of the source circle \\( \\lambda \\) Wavelength of the wave \\( f \\) Frequency \\( A \\) Amplitude (optional: normalize to 1) Grid size Resolution of the visualization","title":"3. Simulation Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-visualization","text":"Use a 2D color map to display the resulting wave amplitude or intensity at each point. Choose either: Snapshot in time (e.g., fixed \\( t = 0 \\) ) Animated sequence for evolving interference","title":"4. Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#summary_1","text":"Step Description Generate \\( N \\) source positions Based on regular polygon around center Compute wave contribution At each point, from each source Apply superposition Sum wave amplitudes (or intensities) Visualize pattern Use color maps to show constructive/destructive regions This strategy creates the foundation for generating visually rich and physically accurate wave interference simulations.","title":"Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-python-simulation-plotting","text":"We simulate the interference pattern by computing the superposition of waves from multiple point sources over a 2D grid. The code below supports: - Configurable number of sources, - Adjustable polygon radius, wavelength, and frequency, - Static snapshot visualization using a 2D color map.","title":"3. Python Simulation &amp; Plotting"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Parameters N = 5 # Number of wave sources (e.g., 3=triangle, 4=square, 5=pentagon) R = 1.0 # Radius of the polygon (in meters) A = 1.0 # Wave amplitude lam = 0.5 # Wavelength (meters) f = 1.0 # Frequency (Hz) omega = 2 * np.pi * f k = 2 * np.pi / lam t = 0 # Snapshot time (seconds) # Grid for visualization grid_size = 500 x = np.linspace(-2, 2, grid_size) y = np.linspace(-2, 2, grid_size) X, Y = np.meshgrid(x, y) eta_total = np.zeros_like(X) # Generate source positions in regular polygon source_coords = [ (R * np.cos(2 * np.pi * i / N), R * np.sin(2 * np.pi * i / N)) for i in range(N) ] # Compute superposition of waves for (x0, y0) in source_coords: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # avoid division by 0 eta = (A / np.sqrt(r)) * np.cos(k * r - omega * t) eta_total += eta # Visualization plt.figure(figsize=(7, 6)) plt.imshow(eta_total, extent=[-2, 2, -2, 2], cmap='viridis', origin='lower') plt.colorbar(label='Displacement \u03b7(x, y, t)') plt.title(f'Interference Pattern: {N} Sources on Polygon') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.axis('equal') plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#how-to-use","text":"Change these values to explore: Parameter Role N Number of sources (polygon type) R Polygon size (radius) lam Wavelength \u2014 controls spacing of fringes f Frequency \u2014 affects animation if implemented t Time snapshot \u2014 static or animated","title":"How to Use"},{"location":"1%20Physics/3%20Waves/Problem_1/#what-this-shows","text":"Bright regions : constructive interference (amplified waves) Dark regions : destructive interference (cancellation) Fringes : result of path differences between wave sources You can extend this model to animations or interactive sliders using ipywidgets or matplotlib.animation .","title":"What This Shows"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-analysis-and-interpretation","text":"The generated interference pattern reveals how waves interact based on their relative phase and source geometry.","title":"4. Analysis and Interpretation"},{"location":"1%20Physics/3%20Waves/Problem_1/#key-features-in-the-pattern","text":"","title":"Key Features in the Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs where waves from different sources arrive in phase , reinforcing each other: Appears as bright or elevated regions . Found along symmetry lines from source to center. Distance differences between sources equal to \\( n \\lambda \\) , where \\( n \\in \\mathbb{Z} \\) .","title":"\u2795 Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs where waves arrive out of phase , cancelling each other: Appears as dark regions or nodes . Wave amplitudes subtract and reduce the total displacement. Happens when path difference equals \\( (n + \\frac{1}{2})\\lambda \\) .","title":"\u2796 Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry-and-geometry","text":"The rotational symmetry of the polygon is reflected in the interference pattern. Triangle \u2192 3-fold symmetry. Square \u2192 4-fold. Pentagon \u2192 5-fold radial patterns. The number of radial arms or nodal lines increases with the number of sources.","title":"Symmetry and Geometry"},{"location":"1%20Physics/3%20Waves/Problem_1/#physical-interpretation","text":"Feature Physical Meaning Sharp bright peaks Regions of high coherence, where waves align perfectly Concentric rings Result from uniform distance differences between pairs of sources Nodal lines Boundaries between constructive and destructive zones Complexity increases with \\( N \\) More interference paths, richer structure","title":"Physical Interpretation"},{"location":"1%20Physics/3%20Waves/Problem_1/#applications","text":"This analysis is analogous to: Water tank experiments (real-life lab visuals) Optical interference (e.g., multiple-slit diffraction) Acoustic systems (speaker arrays, architectural acoustics) Quantum wavefunctions (interference in probability amplitudes) Interference patterns visually encode phase relationships and wave dynamics. By adjusting the number and arrangement of sources, we can design patterns with desired symmetry or cancellation zones \u2014 with applications from physics education to antenna design.","title":"Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Equivalent Resistance Using Graph Theory Motivation Calculating the equivalent resistance is a fundamental task in electrical circuits. While manual methods like series-parallel reduction work for small circuits, they become impractical for complex networks. Graph theory offers a powerful and systematic alternative. By modeling the circuit as a graph: - Nodes represent junctions - Edges represent resistors, with edge weights as resistance values We can iteratively reduce the graph until only a single equivalent resistance remains between the input and output nodes. Algorithm Overview Input : A weighted graph representing the circuit. Repeat until no further simplification is possible: Parallel reduction : If multiple edges exist between two nodes, replace them with a single edge using: $$ R_{\\text{eq}} = \\left( \\sum_i \\frac{1}{R_i} \\right)^{-1} $$ Series reduction : If a node connects to exactly two others (and is not input/output), merge it using: $$ R_{\\text{eq}} = R_1 + R_2 $$ Output : The final resistance between the input and output node. Pseudocode function calculate_equivalent_resistance(graph): while graph can be simplified: for each pair of nodes (u, v): if multiple edges exist between (u, v): # Parallel R_parallel = 1 / sum(1 / R for each edge between u and v) remove all edges between u and v add edge (u, v) with R_parallel for each node n in graph: if degree(n) == 2 and n is not input/output: # Series neighbors = [a, b] R1 = resistance between a and n R2 = resistance between n and b R_total = R1 + R2 remove node n and its edges add edge (a, b) with R_total return resistance of the only remaining edge Test Examples 1. Series connection - Nodes: A \u2014 B \u2014 C - Edges: A\u2013B: 2\u03a9, B\u2013C: 3\u03a9 Expected result: \\[ R_{\\text{eq}} = 2 + 3 = 5\\ \\Omega \\] 2. Parallel connection - Nodes: A, B - Edges: A\u2013B: 4\u03a9, A\u2013B: 6\u03a9 Expected result: \\[ R_{\\text{eq}} = \\left( \\frac{1}{4} + \\frac{1}{6} \\right)^{-1} = 2.4\\ \\Omega \\] 3. Nested configuration - A\u2013B: 2\u03a9 - B\u2013C: 4\u03a9, 4\u03a9 (parallel) - C\u2013D: 1\u03a9 Reduction steps: - B\u2013C in parallel \u2192 2\u03a9 - A\u2013B\u2013C\u2013D in series \u2192 2\u03a9 + 2\u03a9 + 1\u03a9 = 5\u03a9 Advantages of Graph-Based Approach Works for arbitrary topologies Suitable for automation with tools like Python and networkx Efficient for large, nested, or cyclic circuits Conclusion Using graph theory to calculate equivalent resistance simplifies and generalizes the process. It enables automated reasoning, handles arbitrary complexity, and lays the foundation for scalable simulation tools in physics, electrical engineering, and computer science.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating the equivalent resistance is a fundamental task in electrical circuits. While manual methods like series-parallel reduction work for small circuits, they become impractical for complex networks. Graph theory offers a powerful and systematic alternative. By modeling the circuit as a graph: - Nodes represent junctions - Edges represent resistors, with edge weights as resistance values We can iteratively reduce the graph until only a single equivalent resistance remains between the input and output nodes.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-overview","text":"Input : A weighted graph representing the circuit. Repeat until no further simplification is possible: Parallel reduction : If multiple edges exist between two nodes, replace them with a single edge using: $$ R_{\\text{eq}} = \\left( \\sum_i \\frac{1}{R_i} \\right)^{-1} $$ Series reduction : If a node connects to exactly two others (and is not input/output), merge it using: $$ R_{\\text{eq}} = R_1 + R_2 $$ Output : The final resistance between the input and output node.","title":"Algorithm Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"function calculate_equivalent_resistance(graph): while graph can be simplified: for each pair of nodes (u, v): if multiple edges exist between (u, v): # Parallel R_parallel = 1 / sum(1 / R for each edge between u and v) remove all edges between u and v add edge (u, v) with R_parallel for each node n in graph: if degree(n) == 2 and n is not input/output: # Series neighbors = [a, b] R1 = resistance between a and n R2 = resistance between n and b R_total = R1 + R2 remove node n and its edges add edge (a, b) with R_total return resistance of the only remaining edge","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#test-examples","text":"1. Series connection - Nodes: A \u2014 B \u2014 C - Edges: A\u2013B: 2\u03a9, B\u2013C: 3\u03a9 Expected result: \\[ R_{\\text{eq}} = 2 + 3 = 5\\ \\Omega \\] 2. Parallel connection - Nodes: A, B - Edges: A\u2013B: 4\u03a9, A\u2013B: 6\u03a9 Expected result: \\[ R_{\\text{eq}} = \\left( \\frac{1}{4} + \\frac{1}{6} \\right)^{-1} = 2.4\\ \\Omega \\] 3. Nested configuration - A\u2013B: 2\u03a9 - B\u2013C: 4\u03a9, 4\u03a9 (parallel) - C\u2013D: 1\u03a9 Reduction steps: - B\u2013C in parallel \u2192 2\u03a9 - A\u2013B\u2013C\u2013D in series \u2192 2\u03a9 + 2\u03a9 + 1\u03a9 = 5\u03a9","title":"Test Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#advantages-of-graph-based-approach","text":"Works for arbitrary topologies Suitable for automation with tools like Python and networkx Efficient for large, nested, or cyclic circuits","title":"Advantages of Graph-Based Approach"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"Using graph theory to calculate equivalent resistance simplifies and generalizes the process. It enables automated reasoning, handles arbitrary complexity, and lays the foundation for scalable simulation tools in physics, electrical engineering, and computer science.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}